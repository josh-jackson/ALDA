<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Applied Longitudinal Data Analysis</title>
    <link>/</link>
      <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <description>Applied Longitudinal Data Analysis</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Wed, 18 Sep 2019 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Applied Longitudinal Data Analysis</title>
      <link>/</link>
    </image>
    
    <item>
      <title>Week 4</title>
      <link>/lectures/week-4/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      <guid>/lectures/week-4/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#review-from-last-time&#34;&gt;Review from last time&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#interpretation&#34;&gt;Interpretation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#estimation&#34;&gt;Estimation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testing-significance-adapted-from-ben-bolker&#34;&gt;Testing significance (adapted from Ben Bolker)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#quick-aside-p-values-are-not-included&#34;&gt;Quick aside: P values are not included&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#likelihood-ratio-test&#34;&gt;Likelihood ratio test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#likelihood-tests-for-random-effects&#34;&gt;Likelihood tests for random effects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#aic-and-bic&#34;&gt;AIC and BIC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#coefficient-of-determination-equivalents&#34;&gt;Coefficient of determination equivalents&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#level-1-predictors-aka-time-varying-covariates-tvcs&#34;&gt;Level 1 predictors AKA Time-varying covariates (TVCs)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introducing-a-random-slope-for-a-tvc&#34;&gt;Introducing a random slope for a TVC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#interactions-among-level-1-variables&#34;&gt;Interactions among level 1 variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#centering-redux&#34;&gt;Centering redux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lagged-predictors&#34;&gt;lagged predictors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#flexible-time-metrics&#34;&gt;Flexible time metrics&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#categorical-structured-vs-continuous-unstructured&#34;&gt;Categorical (structured) vs continuous (unstructured)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#balanced-vs-unbalanced&#34;&gt;Balanced vs unbalanced&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#convergence-issues-or-other-warnings&#34;&gt;Convergence issues or other warnings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#polynomial-and-splines&#34;&gt;Polynomial and Splines&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#polynomial-example&#34;&gt;polynomial example&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#importance-of-centering&#34;&gt;importance of centering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#random-terms&#34;&gt;random terms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#splines-aka-piecewise&#34;&gt;Splines aka piecewise&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#separate-curves&#34;&gt;separate curves&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#splines-polynomial-polynomial-piecewise&#34;&gt;splines + polynomial = polynomial piecewise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;review-from-last-time&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Review from last time&lt;/h1&gt;
&lt;div id=&#34;interpretation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Interpretation&lt;/h2&gt;
&lt;p&gt;Looked at between person predictors&lt;/p&gt;
&lt;p&gt;Can you to interpret each fixed and random effect?&lt;/p&gt;
&lt;p&gt;What do these different models look like graphically?&lt;/p&gt;
&lt;p&gt;level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Health}_{ij} = \beta_{0j}  + \beta_{1j}Time_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + \gamma_{01}Exercise_{j} +  \gamma_{02}Intervention_{j} +   U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} + \gamma_{11}Intervention_{j} + U_{1j} \]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;estimation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Estimation&lt;/h1&gt;
&lt;p&gt;Now that we are able to build and visualize models, how do we test the parameters of interest?&lt;/p&gt;
&lt;p&gt;Maximum likelihood estimation. Uses a likelihood function that describes the probability of observing the sample data as a function of the parameters. Attempts to maximize the function through an iterative process. Because it is iterative, it might fail.&lt;/p&gt;
&lt;p&gt;There are fixed effects as well as random effects we need to count for. Maximum likelihood takes our assumptions about the model (normally distributed residuals, etc) and creates probability densities for each parameters. For example, based on certain fixed effects and sd of random effects, how likely is it that person x has a slope of z? The algorithm looks at the full sample to see how likely different parameters are, spits back the most likely, and gives you a number to show how likely they are (compared to others). This is akin to saying you rolled 10 dice, 5 came up as 2s. How likely is this dice fair? But instead of fair vs not fair it gives a likelihood to certain possibilities (e.g., a 2 comes up at 25%, 50% 75% rates).&lt;/p&gt;
&lt;p&gt;Restricted maximum likelihood (REML) vs Full Maximum likelihood (ML). Will give you similar parameters, the differences are in the standard errors. REML is similar to dividing by N - 1 for SE whereas ML is similar to dividing by N.&lt;/p&gt;
&lt;p&gt;Differences account for the fact that fixed effects are being estimated simultaneously with the variance parameters in ML. Estimates of the variance parameters assume that the fixed effects estimates are known and thus does not account for uncertainty in these estimates.&lt;/p&gt;
&lt;p&gt;REML accounts for uncertainty in the fixed effects before estimating residual variance. REML attempts to maximize the likelihood of the residuals whereas ML maximizes the sample data. REML can be thought of as an unbiased estimate of the residual variance.&lt;/p&gt;
&lt;p&gt;REML is good for small sample size both N and group. However, if you use REML you should be careful in testing fixed effects against each other (more down below). Deviance tests for fixed effects should be done with ML, but only random effects with REML. ML can also look at random effects too.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;testing-significance-adapted-from-ben-bolker&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Testing significance (adapted from Ben Bolker)&lt;/h1&gt;
&lt;p&gt;4 Methods for testing single parameters
From worst to best:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Wald Z-tests.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Wald t-tests&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Easy to compute - test statistic over standard error However, they are asymptotic standard error approximations, assuming both that (1) the sampling distributions of the parameters are multivariate normal and that (2) the sampling distribution of the log-likelihood is (proportional to) χ2.&lt;/p&gt;
&lt;p&gt;The above two are okay to do for single parameter estimates of fixed effects. But beware that a) degrees of freedom calculations are not straightforward and b) the assumptions for random effects are be hard to meet.&lt;/p&gt;
&lt;div id=&#34;quick-aside-p-values-are-not-included&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Quick aside: P values are not included&lt;/h2&gt;
&lt;p&gt;Authors of the package we will be using first lme4 are not convinced of the utility of the general approach of testing with reference to an approximate null distribution. In general, it is not clear that the null distribution of the computed ratio of sums of squares is really an F distribution, for any choice of denominator degrees of freedom. While this is true for special cases that correspond to classical experimental designs (nested, split-plot, randomized block, etc.), it is apparently not true for more complex designs (unbalanced, GLMMs, temporal or spatial correlation, etc.).&lt;/p&gt;
&lt;p&gt;tl;dr: it gets messy with more complex models.&lt;/p&gt;
&lt;p&gt;If you really want p values&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# library(lmerTest)&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Likelihood ratio test (also called deviance test).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Markov chain Monte Carlo (MCMC) or parametric bootstrap confidence intervals ( we will get to this later)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;likelihood-ratio-test&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Likelihood ratio test&lt;/h2&gt;
&lt;p&gt;Used for model comparisons (often multiparameter comparisons) and for tests of random effects. REML can only be used if model compared have the same fixed parts and only differ in random. Otherwise ML must be used.&lt;/p&gt;
&lt;p&gt;How much more likely the data is under a more complex model than under the simpler model (these models need to be nested to compare this).&lt;/p&gt;
&lt;p&gt;Log Likelihood (LL) is derived from ML estimation. Logs are used because they are computationally simpler; logs of multiplications are reduced to adding the logs together.&lt;/p&gt;
&lt;p&gt;Larger the LL the better the fit.&lt;/p&gt;
&lt;p&gt;Deviance compares two LLs. Current model and a saturated model (that fits data perfectly). Asks how much worse the current model is to the best possible model. Deviance = -2[LL current - LL saturated]&lt;/p&gt;
&lt;p&gt;LL saturated = 1 for MLMs (probability it will perfectly recapture data). log of 1 is 0. So this term drops out. Deviance = -2(LL current model). AKA -2logL or -2LL&lt;/p&gt;
&lt;p&gt;Can compare two models via subtraction, often referred to as a full and reduced model. Differences is distributed as a chi square with a df equal to how many “constraints” are included. Constraints can be thought of as forcing a parameter to be zero ie removing it.&lt;/p&gt;
&lt;p&gt;Comparing 2 models is called a likelihood ratio test. Need to have:
1. same data
2. nested models (think of constraining a parameter to zero)&lt;/p&gt;
&lt;p&gt;Why work with deviances and not just log likelihoods? Why -2? Why a ratio test when you subtract deviances? Maths. Working with deviances allows us to subtract two from one another, which is equivalent to taking the ratio of likelihoods.&lt;/p&gt;
&lt;p&gt;You can test in r using the same procedure we would to test different regression models.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova(mod.2, mod.2r)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;likelihood-tests-for-random-effects&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Likelihood tests for random effects&lt;/h2&gt;
&lt;p&gt;Not listed in the output because it is harder to do this with variances. Remember variances do not have values below zero and thus the distributions get a wonky quickly. Needs mixture distributions (Cannot be easily done with chi square, for example)&lt;/p&gt;
&lt;p&gt;Can technically do anova comparisons for random effects, though that falls to many similar problems as trying to do a Wald test.&lt;/p&gt;
&lt;p&gt;The sampling distribution of variance estimates is in general strongly asymmetric: the standard error may be a poor characterization of the uncertainty. Thus the best way to handle is to do bootstrapped estimates.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;aic-and-bic&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;AIC and BIC&lt;/h2&gt;
&lt;p&gt;Used when you want to compare non-nested data. Need to have the same data, however.&lt;/p&gt;
&lt;p&gt;AIC (Akaike’s Information Criterion) and the BIC (Bayesian Information Criterion) where “smaller is better.” This is the opposite of LL. As with the other types, these may give you wonky findings depending on some factors as they are related to LLs.&lt;/p&gt;
&lt;p&gt;AIC = 2(number of parameters) + (−2LL)
BIC = ln(n)(number of parameters) + (−2LL)&lt;/p&gt;
&lt;p&gt;BIC penalizes models with more parameters more than AIC does.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;coefficient-of-determination-equivalents&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Coefficient of determination equivalents&lt;/h2&gt;
&lt;p&gt;You want to get a model fit estimate. BIC and AIC are good to compare nested models but they aren’t standardized and thus make comparison across non nested models difficult.&lt;/p&gt;
&lt;p&gt;With MLM models we cannot directly compute R2. Instead we will use pseudo R2. Pseudo R2 is similar to R2 in that it can be thought of as the correlation between your predicted and actual scores. For example, assume we have three waves of data. The intercept is 1, the slope is 2 and time is coded 0,1,2. The predicted scores are: 1, 3, 5. We would then correlate everyone’s first, second and third wave scores with these predicted scores. This correlation squared is pseudo R2, telling us how much variance time explains in our DV.&lt;/p&gt;
&lt;p&gt;Yes, we typically think of this as a measure of variance explained divided by total variance. This is where things get tricky: should you include or exclude variation of different random-effects terms? These are error, but they are modeled in the sense that they are not unexplained. Is the effect size wanted after you are “controlling for” or do you want to talk about total variation. There are similarities here with regards to Eta and Partial Eta squared.&lt;/p&gt;
&lt;p&gt;The general idea is to be upfront about what you are comparing and what is included. Typically this is done with comparing models, much like a hierarchical regression. Taking the difference in variance between model 1 and model 2 and dividing it by model 1 makes it explicit what you are looking at and what you are including or not including.&lt;/p&gt;
&lt;p&gt;E.g,. residual variance in varying intercept model subtracted from growth model divided by intercept only model. This can tell you how much unexplained variance is explained by time.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(sigma(mod.1) - sigma(mod.2)) / sigma(mod.1)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;level-1-predictors-aka-time-varying-covariates-tvcs&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Level 1 predictors AKA Time-varying covariates (TVCs)&lt;/h1&gt;
&lt;p&gt;Thus far we have been talking about level 2, between person predictors. But we can extend this to level 1, within person, repeated measures as predictors and covariates.&lt;/p&gt;
&lt;p&gt;These are predictors that are assessed at level 1, which repeat. Note that there are some variables that are inherently level 2 (e.g. handedness), some that make sense more as a level 1 (e.g., mood) and some that could be considered either depending on your research question and/or your data (e.g. income). The latter type could conceivably change across time (And thus be appropriate for a level 1 variable; tvc) but may not change at the rate of your construct or not be important.&lt;/p&gt;
&lt;p&gt;What do level 1 predictors look like in your dataset?&lt;/p&gt;
&lt;p&gt;Consider health across time predicted by a level 1 exercise variable (1 = yes, exercised). Note that we had a similar model presented at the end of last class, but exercise was a level 2 predictor. Be comfortable with how these differ.&lt;/p&gt;
&lt;p&gt;level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Health}_{ij} = \beta_{0j}  + \beta_{1j}Time_{ij} + \beta_{2j}Exercise_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} +   U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} +  U_{1j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{2j} = \gamma_{20} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Combined:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Health}_{ij} =  [\gamma_{00} +   \gamma_{10}Time_{ij}   + \gamma_{20}Exercise_{ij}] + [ U_{0j}  + U_{1j}Time_{ij}+ \varepsilon_{ij}] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Two things to keep in mind:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;These can be treated as another predictor with the effect of “controlling” for some TVC. Thus the regression coefficients in the model are conditional on this covariate.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$ _{10} $ is the average rate of change in health, controlling for exercise&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\gamma_{20}\)&lt;/span&gt; is the average difference in health when exercising and when not. Ie the difference in health trajectory.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\gamma_{00}\)&lt;/span&gt; is the average health at Time = 0 for those that do not exercise. Ie when both predictors are at zero.&lt;/p&gt;
&lt;p&gt;How would you visualize the fixed effects for varying combinations of exercise?&lt;/p&gt;
&lt;div id=&#34;introducing-a-random-slope-for-a-tvc&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introducing a random slope for a TVC&lt;/h2&gt;
&lt;p&gt;Person specific residuals make the interpretation of parameters a little more difficult as the model says that the gap between exercise and not exercise is the same for everyone. Should we allow it to be this way?&lt;/p&gt;
&lt;p&gt;level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Health}_{ij} = \beta_{0j}  + \beta_{1j}Time_{ij} + \beta_{2j}Exercise_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} +   U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} +  U_{1j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{2j} = \gamma_{20} +  U_{2j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2 variance-covariance matrix:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \begin{pmatrix} {U}_{0j} \\ {U}_{1j} \\ {U}_{2j} \end{pmatrix}
\sim \mathcal{N} \begin{pmatrix} 
  0,  &amp;amp;  \tau_{0}^{2} &amp;amp; \tau_{01}   &amp;amp; \tau_{02}   \\ 
  0, &amp;amp; \tau_{10} &amp;amp; \tau_{1}^{2} &amp;amp; \tau_{12}  \\
  0, &amp;amp; \tau_{20} &amp;amp; \tau_{21} &amp;amp; \tau_{2}^{2}
\end{pmatrix} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Residual variance at level 1&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {R}_{ij} \sim \mathcal{N}(0, \sigma^{2})  \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Compared to time invariant (level 2) predictors, tvc/level 1 predictors are likely to explain variance level 1 and level 2 variance terms as they differ between and within. Typically level 2 predictors tend to only reduce level 2 variance. It is possible, however, that including a level 1 predictor will increase the variance in level 2 variance components.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;interactions-among-level-1-variables&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Interactions among level 1 variables&lt;/h2&gt;
&lt;p&gt;Couldn’t exercise levels influence the slope of health? The previous models constrained the slopes to be the same, saying that people differ on level when exercising vs not but not on rate of change.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Health}_{ij} =  [\gamma_{00} +   \gamma_{10}Time_{ij}   + \gamma_{20}Exercise_{ij} + \gamma_{30}TimeXExercise_{ij}]] + [ U_{0j}  + U_{1j}Time_{ij}+ \varepsilon_{ij}] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;How could you visualize this model?&lt;/p&gt;
&lt;p&gt;How do you interpret each of the terms (knowing what you know about interactions)?&lt;/p&gt;
&lt;p&gt;How would all of this change if our level 1 variable was continuous?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;centering-redux&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Centering redux&lt;/h2&gt;
&lt;p&gt;Especially when you are working with level 1 interactions, centering is important to interpret your lower order terms. How would $ _{10}$ be interpreted in the above if exercise was centered vs not? Also, be clear about what you mean by centering. Is it the person average or the grand mean average. These will differ in interpretation. Do you want to model a person’s average exercise or the grand mean exercise?&lt;/p&gt;
&lt;p&gt;Typically for level 1 we will want to within person-mean center.&lt;/p&gt;
&lt;p&gt;However, this gets rid of all mean level information for a person. The question at hand is not whether you exercise more or less it is compared to your typical levels, what happens when you exercise more or less. This is a within-person question and may be quite important for your theoretical tests.&lt;/p&gt;
&lt;p&gt;However, if you are including a level 1 person centered variable in the model, note that 1) the average level of exercise is not controlled for and 2) the variation around the level will likely be related to the persons mean score. In other words, the within and between person variance of exercise is not neatly decomposed. To do so, we will have to create a new variable out of the existing level 1 variable, a person mean.&lt;/p&gt;
&lt;p&gt;Level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Health}_{ij} = \beta_{0j}  + \beta_{1j}Time_{ij} + \beta_{2j}(Exercise_{ij}-\overline{Exercise_{j}}) + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + \gamma_{01}\overline{Exercise_{j}} + U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} +  U_{1j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{2j} = \gamma_{20} +  U_{2j} \]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;lagged-predictors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;lagged predictors&lt;/h2&gt;
&lt;p&gt;We will set these up more in the following weeks. But it is possible to predict Health, using time - 1 previous assessments of exercise. Why might these lagged predictors be helpful?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;flexible-time-metrics&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Flexible time metrics&lt;/h1&gt;
&lt;p&gt;Thus far we have been talking about time relatively naively, assuming that time is fixed on equal assessments for everyone ie wave. This treatment of time can be made more complex in two ways.&lt;/p&gt;
&lt;div id=&#34;categorical-structured-vs-continuous-unstructured&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Categorical (structured) vs continuous (unstructured)&lt;/h2&gt;
&lt;p&gt;Our repeated assessments are often collected based on some sort of structure. You have enough funding for three waves of data, and you proceed to call participants. These three waves may be specified to occur every 6 months, for example. However, it rarely works out that nicely. People don’t show up, people reschedule, your team is in holiday. The resulting time in between assessments thus differs between and within a person. What to do?&lt;/p&gt;
&lt;p&gt;Well, we could ignore the timing differences. Do we think that a few weeks difference will make or break your general conclusions? Sticking with wave is seen as treating time as categorical.&lt;/p&gt;
&lt;p&gt;We could also treat it as continuous. This is usually preferred because why get rid of meaningful information? Within MLMs there is practically no downside to doing so.&lt;/p&gt;
&lt;p&gt;Treating time as categorical, however, is standard with SEM based longitudinal methods.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;balanced-vs-unbalanced&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Balanced vs unbalanced&lt;/h2&gt;
&lt;p&gt;Balanced for longitudinal models means that everyone has the same number of repeated assessments. As with ANOVA/experimental designs, balance makes the math easier. In terms of interpretation of the results after doing said maths, there is no difference. In longitudinal designs especially, it is important is where this unbalance comes from. Does the unbalance occur because of dumb luck or is it systematically related to some variable e.g., attrition via death/health.&lt;/p&gt;
&lt;p&gt;The downfalls from unbalanced designs come from difficulties in convergence and interpretation. This is especially true when time is categorical rather than continuous (as continuous time makes estimation of variance components easier as it is more likely to be separated from the fixed effects).&lt;/p&gt;
&lt;p&gt;If you have less than 2 repeated measures for a person, they still can be used. They will be used to estimate relevant fixed effects that can be estimated (as they are similar to standard regression coefficients), but likely not the variance estimates. The slopes for these people will be based on their observed values and the model based trajectory (ie uses partial pooling/shrinkage). However, a number of these individuals will lead to convergence issues.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;convergence-issues-or-other-warnings&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Convergence issues or other warnings&lt;/h1&gt;
&lt;p&gt;If you have convergence issues it is likely because you have a) too few data points, b) too much imbalance in your repeated measures (ie missing data), c) too many parameters to estimate or d) a combination of all of the above.&lt;/p&gt;
&lt;p&gt;We will talk about fitting a “maximal model” – one that has as many variance components as possible. However, this may be asking too much of the data. Instead, we may have to get rid of some of these random terms to reduce model complexity.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;polynomial-and-splines&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Polynomial and Splines&lt;/h1&gt;
&lt;p&gt;##Polynomials
level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  + \beta_{1j}(Time_{ij} - \bar{X)} + \beta_{2j}(Time_{ij} - \bar{X)}^2 + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} +   U_{0j}\]&lt;/span&gt;&lt;br /&gt;
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} +  U_{1j} \]&lt;/span&gt;
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{2j} = \gamma_{20} +  U_{2j} \]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&#34;polynomial-example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;polynomial example&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rm(list = ls())

library(readr)
cdrs &amp;lt;- read_csv(&amp;quot;~/Box/5165 Applied Longitudinal Data Analysis/Longitudinal/cdrs.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Parsed with column specification:
## cols(
##   mapid = col_double(),
##   exclude = col_character(),
##   cdr = col_double(),
##   testdate = col_double()
## )&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;personality &amp;lt;- read_csv(&amp;quot;~/Box/5165 Applied Longitudinal Data Analysis/Longitudinal/Subject_personality.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Parsed with column specification:
## cols(
##   mapid = col_double(),
##   age = col_double(),
##   neodate = col_double(),
##   neuroticism = col_double(),
##   extraversion = col_double(),
##   openness = col_double(),
##   agreeablness = col_double(),
##   conscientiousness = col_double(),
##   gender = col_character()
## )&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2) 


gg1 &amp;lt;- ggplot(personality,
   aes(x = neodate, y = neuroticism, group = mapid)) + geom_line()  
gg1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 1 rows containing missing values (geom_path).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/2019-09-18-week-4_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Attaching packages ──────────────────────────────────────── tidyverse 1.2.1.9000 ──&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ✔ tibble  2.1.3           ✔ dplyr   0.8.3      
## ✔ tidyr   0.8.99.9000     ✔ stringr 1.4.0      
## ✔ purrr   0.3.2           ✔ forcats 0.4.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Conflicts ──────────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;personality&amp;lt;- personality %&amp;gt;% 
  group_by(mapid) %&amp;gt;%
  arrange(neodate) %&amp;gt;% 
  mutate(wave = seq_len(n())) &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg2 &amp;lt;- ggplot(personality,
   aes(x = wave, y = neuroticism, group = mapid)) + geom_line()  
gg2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/2019-09-18-week-4_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;personality$neodate &amp;lt;- as.Date(personality$neodate, origin = &amp;quot;1900-01-01&amp;quot;)

gg3 &amp;lt;- ggplot(personality,
   aes(x = neodate, y = neuroticism, group = mapid)) + geom_line()  
gg3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 1 rows containing missing values (geom_path).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/2019-09-18-week-4_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## convert to days from first assessment

personality.wide &amp;lt;- personality %&amp;gt;% 
  dplyr::select(mapid, wave, neodate) %&amp;gt;% 
  spread(wave, neodate) 

personality.wide$wave_1 &amp;lt;- personality.wide$&amp;#39;1&amp;#39;
personality.wide$wave_2 &amp;lt;- personality.wide$&amp;#39;2&amp;#39;
personality.wide$wave_3 &amp;lt;- personality.wide$&amp;#39;3&amp;#39;
personality.wide$wave_4 &amp;lt;- personality.wide$&amp;#39;4&amp;#39;
personality.wide$wave_5 &amp;lt;- personality.wide$&amp;#39;5&amp;#39;

personality.wide &amp;lt;- personality.wide %&amp;gt;% 
mutate (w_1 = (wave_1 - wave_1)/365,
          w_2 = (wave_2 - wave_1)/365,
          w_3 = (wave_3 - wave_1)/365,
          w_4 = (wave_4 - wave_1)/365,
        w_5 = (wave_5 - wave_1)/365)

personality.long &amp;lt;- personality.wide %&amp;gt;% 
  dplyr::select(mapid, w_1:w_5) %&amp;gt;% 
  gather(wave, year, -mapid) %&amp;gt;% 
  separate(wave, c(&amp;#39;weeks&amp;#39;, &amp;#39;wave&amp;#39; ), sep=&amp;quot;_&amp;quot;) %&amp;gt;% 
 dplyr::select(-weeks) 

personality.long$wave &amp;lt;-  as.numeric(personality.long$wave)


personality &amp;lt;- personality %&amp;gt;% 
   left_join(personality.long, by = c(&amp;#39;mapid&amp;#39;, &amp;#39;wave&amp;#39; )) &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg4 &amp;lt;- ggplot(personality,
   aes(x = year, y = neuroticism, group = mapid)) + geom_line()  
gg4&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Don&amp;#39;t know how to automatically pick scale for object of type difftime. Defaulting to continuous.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 1 rows containing missing values (geom_path).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/2019-09-18-week-4_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(lme4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: Matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;Matrix&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &amp;#39;package:tidyr&amp;#39;:
## 
##     expand, pack, unpack&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1 &amp;lt;- lmer(neuroticism ~ year + (1 | mapid), data=personality)
summary(p1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: neuroticism ~ year + (1 | mapid)
##    Data: personality
## 
## REML criterion at convergence: 13657.4
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.7877 -0.4675 -0.0227  0.4289  3.3166 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  mapid    (Intercept) 42.16    6.493   
##  Residual             15.65    3.956   
## Number of obs: 2105, groups:  mapid, 1090
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept) 16.05632    0.22577  71.118
## year        -0.13204    0.03247  -4.067
## 
## Correlation of Fixed Effects:
##      (Intr)
## year -0.247&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(lme4)
personality.s &amp;lt;- personality %&amp;gt;% 
  group_by(mapid) %&amp;gt;% 
  tally() %&amp;gt;% 
   filter(n &amp;gt;=2) 

 personality &amp;lt;- personality %&amp;gt;% 
   filter(mapid %in% personality.s$mapid)

p2 &amp;lt;- lmer(neuroticism ~ year + (1 | mapid), data=personality)
summary(p2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: neuroticism ~ year + (1 | mapid)
##    Data: personality
## 
## REML criterion at convergence: 10396.9
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.7542 -0.5122 -0.0282  0.4698  3.3369 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  mapid    (Intercept) 40.92    6.397   
##  Residual             15.61    3.950   
## Number of obs: 1635, groups:  mapid, 620
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept)  15.3797     0.2915  52.761
## year         -0.1083     0.0331  -3.271
## 
## Correlation of Fixed Effects:
##      (Intr)
## year -0.320&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p3 &amp;lt;- lmer(neuroticism ~ year + (year | mapid), data=personality)
summary(p3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: neuroticism ~ year + (year | mapid)
##    Data: personality
## 
## REML criterion at convergence: 10389.2
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.7440 -0.4825 -0.0304  0.4443  3.3453 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev. Corr 
##  mapid    (Intercept) 41.6916  6.4569        
##           year         0.0983  0.3135   -0.10
##  Residual             14.2561  3.7757        
## Number of obs: 1635, groups:  mapid, 620
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept) 15.37237    0.29136  52.760
## year        -0.10271    0.03602  -2.851
## 
## Correlation of Fixed Effects:
##      (Intr)
## year -0.317&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;importance-of-centering&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;importance of centering&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;personality$year &amp;lt;- as.numeric(personality$year)
  
p4 &amp;lt;- lmer(neuroticism ~ year + I(year^2) + (year | mapid), data=personality)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in checkConv(attr(opt, &amp;quot;derivs&amp;quot;), opt$par, ctrl =
## control$checkConv, : Model failed to converge with max|grad| = 0.00216391
## (tol = 0.002, component 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(p4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: neuroticism ~ year + I(year^2) + (year | mapid)
##    Data: personality
## 
## REML criterion at convergence: 10395.8
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.7664 -0.4836 -0.0251  0.4422  3.3259 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev. Corr 
##  mapid    (Intercept) 41.73017 6.4599        
##           year         0.09818 0.3133   -0.10
##  Residual             14.26174 3.7765        
## Number of obs: 1635, groups:  mapid, 620
## 
## Fixed effects:
##              Estimate Std. Error t value
## (Intercept) 15.324317   0.297096  51.580
## year        -0.031791   0.092090  -0.345
## I(year^2)   -0.008789   0.010490  -0.838
## 
## Correlation of Fixed Effects:
##           (Intr) year  
## year      -0.300       
## I(year^2)  0.194 -0.920
## convergence code: 0
## Model failed to converge with max|grad| = 0.00216391 (tol = 0.002, component 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# woah, how do I interpret this? WHy all of a sudden non-sig? 
# what would happen if I changed my time metric? &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(psych)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;psych&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &amp;#39;package:ggplot2&amp;#39;:
## 
##     %+%, alpha&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;describe(personality$year)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    vars    n mean   sd median trimmed  mad min   max range skew kurtosis
## X1    1 1635  3.1 3.29   2.45    2.66 3.63   0 12.78 12.78  0.8    -0.41
##      se
## X1 0.08&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;personality$year.c &amp;lt;- personality$year - 3.1

p5 &amp;lt;- lmer(neuroticism ~ year.c + I(year.c^2) + (year.c | mapid), data=personality)
summary(p5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: neuroticism ~ year.c + I(year.c^2) + (year.c | mapid)
##    Data: personality
## 
## REML criterion at convergence: 10395.8
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.7663 -0.4836 -0.0251  0.4422  3.3258 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev. Corr
##  mapid    (Intercept) 41.42901 6.4365       
##           year.c       0.09812 0.3132   0.05
##  Residual             14.26278 3.7766       
## Number of obs: 1635, groups:  mapid, 620
## 
## Fixed effects:
##              Estimate Std. Error t value
## (Intercept) 15.141297   0.296070  51.141
## year.c      -0.086286   0.041061  -2.101
## I(year.c^2) -0.008789   0.010490  -0.838
## 
## Correlation of Fixed Effects:
##             (Intr) year.c
## year.c       0.226       
## I(year.c^2) -0.353 -0.480&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;random-terms&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;random terms&lt;/h3&gt;
&lt;p&gt;fitting a random slope plus a random quadratic leads to difficulties ie non-convergence. What does this model say?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p6 &amp;lt;- lmer(neuroticism ~ year + I(year^2) + ( I(year^2) | mapid), data=personality)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in checkConv(attr(opt, &amp;quot;derivs&amp;quot;), opt$par, ctrl =
## control$checkConv, : Model failed to converge with max|grad| = 0.167875
## (tol = 0.002, component 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in checkConv(attr(opt, &amp;quot;derivs&amp;quot;), opt$par, ctrl = control$checkConv, : Model is nearly unidentifiable: very large eigenvalue
##  - Rescale variables?&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(p6)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: neuroticism ~ year + I(year^2) + (I(year^2) | mapid)
##    Data: personality
## 
## REML criterion at convergence: 10398.9
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.7747 -0.4937 -0.0197  0.4525  3.3481 
## 
## Random effects:
##  Groups   Name        Variance  Std.Dev. Corr
##  mapid    (Intercept) 4.082e+01 6.38890      
##           I(year^2)   4.851e-04 0.02203  0.02
##  Residual             1.505e+01 3.87965      
## Number of obs: 1635, groups:  mapid, 620
## 
## Fixed effects:
##              Estimate Std. Error t value
## (Intercept) 15.321498   0.296523  51.670
## year        -0.026955   0.093386  -0.289
## I(year^2)   -0.009488   0.010729  -0.884
## 
## Correlation of Fixed Effects:
##           (Intr) year  
## year      -0.300       
## I(year^2)  0.202 -0.928
## convergence code: 0
## Model failed to converge with max|grad| = 0.167875 (tol = 0.002, component 1)
## Model is nearly unidentifiable: very large eigenvalue
##  - Rescale variables?&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;splines-aka-piecewise&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Splines aka piecewise&lt;/h2&gt;
&lt;p&gt;Fit more than 1 trajectory. Best to use when we have a reason for a qualitative difference at some identified time point. For example, before your health event you may have a different trajectory than after it and thus you would want to model two separate trajectories. Splines allow you to do this in a single model. You can do this in simple regression and the logic follows for growth models.&lt;/p&gt;
&lt;p&gt;We simply replace time with dummy variables that represent different segments we wish to model. The point of separation is called a knot. You can have as many as you want and these can be pre-specified (usually for our case) or in more advanced treatments have the data specify it for you.&lt;/p&gt;
&lt;div id=&#34;separate-curves&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;separate curves&lt;/h3&gt;
&lt;p&gt;The most common is to create different trajectories that change across knots. The easiest example is to take your time variable and transform it into a Time1 and time2, that represent the different time periods. This is easiest to see if we choose our wave variable as our time metric, though you do not have to necessarily do it this way.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t1 &amp;lt;- tribble(
  ~time, ~t0, ~t1,~t2,~t3,~t4,~t5,
  &amp;quot;time 1&amp;quot;, 0, 1,2,2,2,2,
  &amp;quot;time 2&amp;quot;, 0, 0,0,1,2,3
)
t1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 7
##   time      t0    t1    t2    t3    t4    t5
##   &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 time 1     0     1     2     2     2     2
## 2 time 2     0     0     0     1     2     3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The idea is that once you hit the knot your value stays the same. Same logic for the second knot, until you get to that knot you don’t have a trajectory.&lt;/p&gt;
&lt;p&gt;###incremental curves
This can be contrasted with a different type of coding, called incremental. Here the first trajectory keeps going, whereas the second trajectory starts at the position of the knot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t2 &amp;lt;- tribble(
  ~time, ~t0, ~t1,~t2,~t3,~t4,~t5,
  &amp;quot;time 1&amp;quot;, 0, 1,2,3,4,5,
  &amp;quot;time 2&amp;quot;, 0, 0,0,1,2,3
)
t2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 7
##   time      t0    t1    t2    t3    t4    t5
##   &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 time 1     0     1     2     3     4     5
## 2 time 2     0     0     0     1     2     3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The two coding schemes propose the same type of trajectory, the only thing that differs is the interpretation of the coefficients.&lt;/p&gt;
&lt;p&gt;In the first, the two slope coefficients represent the actual slope in the respective time period.&lt;/p&gt;
&lt;p&gt;In the second, the coefficient for time 2 represents the deviation from the slope in period 1. The positive of this second method is you can easily test whether these two slopes are different from one another.&lt;/p&gt;
&lt;p&gt;level 1:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  + \beta_{1j}Time1_{ij} + \beta_{2j}Time2_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} +  U_{0j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} +  U_{1j} \]&lt;/span&gt;
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{2j} = \gamma_{20} +  U_{2j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;###splines example&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;personality$time1 &amp;lt;- recode(personality$wave, &amp;#39;1&amp;#39; = 0 , &amp;#39;2&amp;#39; = 1,  &amp;#39;3&amp;#39; = 1, &amp;#39;4&amp;#39; = 1,&amp;#39;5&amp;#39; = 1)      
personality$time2 &amp;lt;- recode(personality$wave, &amp;#39;1&amp;#39; = 0 , &amp;#39;2&amp;#39; = 0,  &amp;#39;3&amp;#39; = 1, &amp;#39;4&amp;#39; = 2,&amp;#39;5&amp;#39; = 3) &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p7 &amp;lt;- lmer(conscientiousness ~ time1 + time2 + (time1   | mapid) , data=personality)
summary(p7)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: conscientiousness ~ time1 + time2 + (time1 | mapid)
##    Data: personality
## 
## REML criterion at convergence: 10003.8
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -5.2558 -0.4068  0.0272  0.4304  4.5854 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev. Corr 
##  mapid    (Intercept) 32.979   5.743         
##           time1        4.729   2.175    -0.13
##  Residual             10.702   3.271         
## Number of obs: 1635, groups:  mapid, 620
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept)  34.1871     0.2654 128.800
## time1        -0.5365     0.2018  -2.658
## time2         0.2184     0.1561   1.399
## 
## Correlation of Fixed Effects:
##       (Intr) time1 
## time1 -0.370       
## time2  0.000 -0.301&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg5 &amp;lt;- ggplot(personality, aes(x = wave, y = conscientiousness, group = mapid)) +  stat_smooth(method = &amp;#39;lm&amp;#39;, formula = y ~ poly(x,2, raw = TRUE),data = personality, aes(x = wave, y = conscientiousness, group=1)) + scale_y_continuous(limits = c(30, 40))
gg5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 609 rows containing non-finite values (stat_smooth).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/2019-09-18-week-4_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;splines-polynomial-polynomial-piecewise&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;splines + polynomial = polynomial piecewise&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  + \beta_{1j}Time1_{ij} +  \beta_{2j}Time1_{ij}^2 + \beta_{3j}Time2_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} +  U_{0j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} +  U_{1j} \]&lt;/span&gt;
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{2j} = \gamma_{20} +  U_{2j} \]&lt;/span&gt;
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{3j} = \gamma_{30} +  U_{3j}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Week 3</title>
      <link>/lectures/2019-08-14-lecture-3-test/</link>
      <pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate>
      <guid>/lectures/2019-08-14-lecture-3-test/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#conditional-models&#34;&gt;Conditional models&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#level-2-predictors&#34;&gt;Level 2 predictors&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#group-predictors-of-intercept&#34;&gt;Group predictors of intercept&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#interpretation-of-fixed-effects&#34;&gt;Interpretation of fixed effects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#interpretation-of-random-effects&#34;&gt;Interpretation of random effects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#seperatinng-these-into-intercept-and-slope&#34;&gt;Seperatinng these into intercept and slope&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#slope-and-intercept-group-predictors&#34;&gt;Slope and Intercept Group Predictors&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#cross-level-interactions&#34;&gt;Cross-level interactions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#equations-necessary-for-plotting&#34;&gt;Equations necessary for plotting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#continuous-predictors-of-intercept-and-slope&#34;&gt;Continuous predictors of intercept and slope&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#equations-necessary-for-plotting-1&#34;&gt;Equations necessary for plotting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-more-level-2-predictors&#34;&gt;Adding more level 2 predictors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#centering&#34;&gt;Centering&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#types-of-centering&#34;&gt;Types of centering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#time-centering&#34;&gt;Time centering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#level-2-centering&#34;&gt;Level 2 centering&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#random-effects-and-residual-standard-assumptions&#34;&gt;Random effects and residual (standard) assumptions&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#data-generating-process-dgp&#34;&gt;Data generating process (DGP)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#estimation&#34;&gt;Estimation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testing-significance-adapted-from-ben-bolker&#34;&gt;Testing significance (adapted from Ben Bolker)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#quick-aside-p-values-are-not-included&#34;&gt;Quick aside: P values are not included&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#likelihood-ratio-test&#34;&gt;Likelihood ratio test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#likelihood-tests-for-random-effects&#34;&gt;Likelihood tests for random effects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#aic-and-bic&#34;&gt;AIC and BIC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#coefficient-of-determination-equivalents&#34;&gt;Coefficient of determination equivalents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#level-1-predictors-aka-time-varying-covariates-tvcs&#34;&gt;Level 1 predictors AKA Time-varying covariates (TVCs)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;conditional-models&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conditional models&lt;/h1&gt;
&lt;p&gt;We are now going to introduce predictors to our models. These predictors are similar to predictors in standard regression – dummy for nominal, interactions change lower order terms, etcetera. These predictors can occur at different levels. Just like in standard regression, there are different ways to interpret the resulting coefficients depending on the type and where the predictor is added.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;level-2-predictors&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Level 2 predictors&lt;/h1&gt;
&lt;div id=&#34;group-predictors-of-intercept&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Group predictors of intercept&lt;/h2&gt;
&lt;p&gt;Starting with the basic, let’s add a group level variable to the model that is dummy coded. Note that group here only is measured once, it is a between person variable. Thus it can only be meaningfully added to level 2. Here we are asking the question, does group 1 differ from group 2 in their…?&lt;/p&gt;
&lt;p&gt;level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  + \beta_{1j}Time_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + \gamma_{01}G_{j} +   U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} + U_{1j} \]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&#34;interpretation-of-fixed-effects&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Interpretation of fixed effects&lt;/h3&gt;
&lt;p&gt;Notice we have a new gamma term, &lt;span class=&#34;math inline&#34;&gt;\(\gamma_{01}\)&lt;/span&gt;. How do we interpret this new fixed effect, especially in the presense of other fixed effects? What is the slope and what is the effect of group on the slope? &lt;span class=&#34;math inline&#34;&gt;\(\gamma_{00}\)&lt;/span&gt; is the intercept and can be considered the slope when G = 0 whereas the &lt;span class=&#34;math inline&#34;&gt;\(\gamma_{01}\)&lt;/span&gt; is the difference in slope between groups. What is then the slope for the group = 1? &lt;span class=&#34;math inline&#34;&gt;\(\gamma_{00} + \gamma_{01}\)&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;interpretation-of-random-effects&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Interpretation of random effects&lt;/h3&gt;
&lt;p&gt;One thing to keep in mind is that we are now changing the meaning of the random effect. Previously, the random effect was interpretted as the deviation from the mean of the interept. These random effects are interpretted almost like residual terms where it is what is left over. Now that we have a predictor in the model, the &lt;span class=&#34;math inline&#34;&gt;\(U_{0j}\)&lt;/span&gt; is the person specific deviation from the group predicted intercept, not the grand mean intercept. It is the difference from what would be expected given all the terms. In other words, it is conditional on all other predictors in the model.&lt;/p&gt;
&lt;p&gt;Combined
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \gamma_{00} + \gamma_{01}G_{j}+  \gamma_{10} (Time_{ij}) + U_{0j} + U_{1j}(Time_{ij}) + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;It is helpful to start looking at your equation in terms of what to expect in your model output. Here you have 3 fixed effects, two random effects, and one residual term.&lt;/p&gt;
&lt;p&gt;Level 2 covariance matrix
&lt;span class=&#34;math display&#34;&gt;\[ \begin{pmatrix} {U}_{0j} \\ {U}_{1j} \end{pmatrix}
\sim \mathcal{N} \begin{pmatrix} 
  0,     &amp;amp; \tau_{00}^{2} &amp;amp; \tau_{01}\\ 
  0, &amp;amp; \tau_{01} &amp;amp; \tau_{10}^{2}
\end{pmatrix} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Same as before in terms of struture, but the calculations will be slightly different. Why?&lt;/p&gt;
&lt;p&gt;Level 1 residual variance
&lt;span class=&#34;math display&#34;&gt;\[ {R}_{ij} \sim \mathcal{N}(0, \sigma^{2})  \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Same as before too. But, would you expect the residual to be smaller or larger compared to a model without a group predictor of the itnercept?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;seperatinng-these-into-intercept-and-slope&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Seperatinng these into intercept and slope&lt;/h3&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = [\gamma_{00} + \gamma_{01}G_{j}+ U_{0j}]  + [(\gamma_{10}  + U_{1j})(Time_{ij})] + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Understanding how to re-write the equation will help for calculating estimated scores for your predictors in addition to being able to interpret the coefficients. This is going to be helpful for predictions and graphing, come later.&lt;/p&gt;
&lt;p&gt;What would differ between the two equations if calculating predicted scores for group coded = 0 versus a group = 1?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;slope-and-intercept-group-predictors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Slope and Intercept Group Predictors&lt;/h2&gt;
&lt;p&gt;Predicting the intrecept only can only answer static questions, not about change. To do that we need to introduce predictions for the slope variable, as that is our variable that indexes how people change.&lt;/p&gt;
&lt;p&gt;level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  + \beta_{1j}Time_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + \gamma_{01}G_{j} +   U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} + \gamma_{11}G_{j} + U_{1j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Similar to before, the interpretation of &lt;span class=&#34;math inline&#34;&gt;\(U_{1j}\)&lt;/span&gt; changes. The term is now what is left over after accounting for group differences in the mean slope.&lt;/p&gt;
&lt;p&gt;Can you visualize what &lt;span class=&#34;math inline&#34;&gt;\(U_{1j}\)&lt;/span&gt; captures? Can you visualize how &lt;span class=&#34;math inline&#34;&gt;\(U_{1j}\)&lt;/span&gt; differs in this model and one that does not have the &lt;span class=&#34;math inline&#34;&gt;\(\gamma_{11}G_{j}\)&lt;/span&gt; term?&lt;/p&gt;
&lt;p&gt;Combined
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \gamma_{00} + \gamma_{01}G_{j}+  \gamma_{10} (Time_{ij}) + \gamma_{11}(G_{j}*Time_{ij}) +  U_{0j} + U_{1j}(Time_{ij}) + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&#34;cross-level-interactions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Cross-level interactions&lt;/h3&gt;
&lt;p&gt;Notice that when we combine Level 1 and Level 2, the slope effect predictor becomes an interaction with time. This is called “cross-level” interaction. Anytime you have a predictor of time that will be an interaction with time in that we are asking does group status (or what ever variable) differs in their trajectory across time. One of these is a level 2 predictor and one is a level 1 predictor, thus a “cross level” interaction. Even though we don’t explicitly model an interaction, it is there because you are inserting the level to prediction, within the level 1 model to get your combined model. As a result, you are replacing your $ {}&lt;em&gt;{1j} $ (that was originally multipled by your level 1 time variable), by $ &lt;/em&gt;{10} + &lt;em&gt;{11}G&lt;/em&gt;{j} + U_{1j} $. Each of these in turn must be multipled with time.&lt;/p&gt;
&lt;p&gt;Level 2 covariance matrix
&lt;span class=&#34;math display&#34;&gt;\[ \begin{pmatrix} {U}_{0j} \\ {U}_{1j} \end{pmatrix}
\sim \mathcal{N} \begin{pmatrix} 
  0,     &amp;amp; \tau_{00}^{2} &amp;amp; \tau_{01}\\ 
  0, &amp;amp; \tau_{01} &amp;amp; \tau_{10}^{2}
\end{pmatrix} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;How does your variance-covariance matrix change? What is the interpretation of &lt;span class=&#34;math inline&#34;&gt;\(\tau_{01}\)&lt;/span&gt;? It is the association between random effects after accounting for (controling) group differences in intercept and slope.&lt;/p&gt;
&lt;p&gt;Level 1 residual variance
&lt;span class=&#34;math display&#34;&gt;\[ {R}_{ij} \sim \mathcal{N}(0, \sigma^{2})  \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;How does your residual change relative to a model without group effects? Can you graph conceptually what this now captures?&lt;/p&gt;
&lt;p&gt;Alternative combined
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = [\gamma_{00} + U_{0j} +\gamma_{01}G_{j}] + [(\gamma_{10}  + \gamma_{11}G_{j}+  U_{1j})(Time_{ij})] + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This is just rearranged so you can see that different groups have different intercepts and slopes – very much alike simple slopes analyses for interactions in standard regression.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;equations-necessary-for-plotting&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Equations necessary for plotting&lt;/h3&gt;
&lt;p&gt;Note that the above equation can be simplified to get rid of the random effects to focus only on fixed effects portion. This is what you would use to get an estimated trajectory. This can be easily lifted from your output.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \hat{Y}_{ij} = [\gamma_{00} +\gamma_{01}G_{j}] + [(\gamma_{10}  + \gamma_{11}G_{j})(Time_{ij})] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Notice how when G = 0, the equation simplifies:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[     \hat{Y}_{ij} = \gamma_{00} + \gamma_{10} (Time_{ij}) \]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;continuous-predictors-of-intercept-and-slope&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Continuous predictors of intercept and slope&lt;/h2&gt;
&lt;p&gt;Introducing a continuous predictor is similar to the group predictors, and is similar to how continuous predictors are used in regression – remember, MLM, is just fancy regression. Here the continuous predictor is again only measured once. It is thought of as a between person variable, one that is not assessed multiple times. As a result, it must go into a level 2 equation.&lt;/p&gt;
&lt;p&gt;level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  + \beta_{1j}Time_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + \gamma_{01}C_{j} +   U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} + \gamma_{11}C_{j} + U_{1j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Combined:
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \gamma_{00} + \gamma_{01}C_{j}+  \gamma_{10} (Time_{ij}) + \gamma_{11}(C_{j}*Time_{ij}) +  U_{0j} + U_{1j}(Time_{ij}) + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;As with nominal level 2 predictors, the interpretation of our intercept is now when all preditors are at zero ie time AND C.&lt;/p&gt;
&lt;p&gt;The &lt;span class=&#34;math inline&#34;&gt;\(\gamma_{01}C_{j}\)&lt;/span&gt; is now the effect of time when the continous predictor is zero. Zero is meaningful when you code for dummy or effect variables, but is not always straightforward with continuous variables. It is thus recommended to &lt;em&gt;always&lt;/em&gt; center your predictors to aide in interpretation. More on what we mean by this below.&lt;/p&gt;
&lt;p&gt;The &lt;span class=&#34;math inline&#34;&gt;\(\gamma_{11}\)&lt;/span&gt; coefficient is now the difference in slopes for one unit of our C variable.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U_{0j}\)&lt;/span&gt; Is the random effect for intercept after accounting for C.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U_{1j}\)&lt;/span&gt; Is the random effect for the slope after accounting for C.&lt;/p&gt;
&lt;p&gt;The covariance between them is now accounting for or controlling for this predictor.&lt;/p&gt;
&lt;div id=&#34;equations-necessary-for-plotting-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Equations necessary for plotting&lt;/h3&gt;
&lt;p&gt;The same logic for plotting models with nominal variables applies to continuous predictor variables. Remembering back to decomposing interactions in standard regression models, it is important to plot predicted lines at different levels of interest. Usually plus minus one SD, but if other levels are interesting then you can do that too.&lt;/p&gt;
&lt;p&gt;As an example, lets say we have the mean of C = 0 with a SD of 1. What would our equation look like to plot a predicted trajectory a SD above and below, as well as mean trajectory?&lt;/p&gt;
&lt;p&gt;-1sd
&lt;span class=&#34;math display&#34;&gt;\[ \hat{Y}_{ij} = [\gamma_{00} +(\gamma_{01}*-1)] + [(\gamma_{10}  + (\gamma_{11}*-1))(Time_{ij})] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Mean
&lt;span class=&#34;math display&#34;&gt;\[ \hat{Y}_{ij} = \gamma_{00} + \gamma_{10}  (Time_{ij}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;+1sd
&lt;span class=&#34;math display&#34;&gt;\[ \hat{Y}_{ij} = [\gamma_{00} +\gamma_{01}] + [(\gamma_{10}  + \gamma_{11})(Time_{ij})] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;What would individual level trajectories look like?&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = [\gamma_{00} + \gamma_{01}C_{j}+  U_{0j}] + [(\gamma_{10}  + \gamma_{11} + U_{1j})   (Time_{ij})] + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Notice how these are just the level 2 equations, to specify intercept and slope.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;adding-more-level-2-predictors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Adding more level 2 predictors&lt;/h2&gt;
&lt;p&gt;These same principles apply to more complex models. As the semester progresses we can continue to add in more complex models, as well as the ability to compare models that differ in complexity.&lt;/p&gt;
&lt;p&gt;It is important to be able to interpret and visualize what these more complex models may look like. For example, can you think about the interpretation of each parameter as well as the plots you would want to do for a model such as looking at health across time, examing the effects of an intervention, while controlling for initial exercise status?:&lt;/p&gt;
&lt;p&gt;level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Health}_{ij} = \beta_{0j}  + \beta_{1j}Time_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2:
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + \gamma_{01}Exercise_{j} +  \gamma_{02}Intervention_{j} +   U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} + \gamma_{11}Intervention_{j} + U_{1j} \]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;centering&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Centering&lt;/h1&gt;
&lt;div id=&#34;types-of-centering&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Types of centering&lt;/h2&gt;
&lt;p&gt;Changing the scale of your predictors changes the interpretation of your model. (Redux of how to interpret lower order terms in an interaction regression model.) We have more options for centering here compared to standard regression, however.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Original metric (no centering)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Group-mean centering (our group/nesting is person so this is also called person centering). This will be more appropriate when we talk about level 1 predictors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Grand-mean centering (this is taking the average across everyone)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Centering on a value of theoretical or applied interest&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Importantly, centering can both change the interpretation of the coefficients, as well as the fit of the model. The latter is especially true when 1) people differ on the number of assessment points (ie grand mean =/= average person mean) and 2) the intercept is far away from a group or grand mean. The latter will influence the random effect variances and their covariances. You can see this with time.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;time-centering&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Time centering&lt;/h2&gt;
&lt;p&gt;Our time variable is our only level 1 predictor that we have worked with up to this point. Thus far we have centered it at the beginning. We typically center time around each person’s initial time to make the intercept more interpretable. However, this can cause correlations between an intercept and a slope. If high, the correlation can be problematic in terms of estimation. Often we center time in the middle of the repeated assessments to minimize this association. Doing so is especially important if you want to use some variable to predict intercept and slope (or use interecept/slope to predict some variable).&lt;/p&gt;
&lt;p&gt;Can you visualize why a slope may be more or less correlated with an intercept depending on how we scale time?&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \begin{pmatrix} {U}_{0j} \\ {U}_{1j} \end{pmatrix}
\sim \mathcal{N} \begin{pmatrix} 
  0,     &amp;amp; \tau_{00}^{2} &amp;amp; \tau_{01}\\ 
  0, &amp;amp; \tau_{01} &amp;amp; \tau_{10}^{2}
\end{pmatrix} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;It is sometimes helpful to center time as the last time point. Why? So as to use a predictor in the model that is trying to longitudinally predict from the initial point, not change, but a timepoint far in the future&lt;/p&gt;
&lt;p&gt;We will talk more about centering later, but it is important to note that it can get tricky for longitudinal models when people don’t have the same number of assessment waves or the same timespan. Where do you center? One option, the most clean, is to center within each person’s own time, regardless of whether it lines up with others. This is #2 above. This is nice because it makes the &lt;span class=&#34;math inline&#34;&gt;\(\gamma_{00}\)&lt;/span&gt; interpretable as the average score across people.&lt;/p&gt;
&lt;p&gt;However, what is the average score? If you are looking at longitudinal data where people span in age from 20 to 80 and the time each person was in the study differed from 1 to 10 years. How do you interpret the average person intercept? Data wise it is consistent but interpretation wise it may not be. Thus you may want to center on an age ie #4 above. The &lt;span class=&#34;math inline&#34;&gt;\(\gamma_{00}\)&lt;/span&gt; can now easily be interpreted as age 40, for example. Buuut, this results in wonky residual terms, perhaps leading to greater covariance between intercept and slope.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;level-2-centering&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Level 2 centering&lt;/h2&gt;
&lt;p&gt;Because level 2 is involved with cross level interactions, it is always helpful to at least consider centering. For level 2, the centering options are much easier, as one can generally go with grand mean centering. As everyone has only 1 value to contribute to, the calculation and the interpretation is more straightforward.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;random-effects-and-residual-standard-assumptions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Random effects and residual (standard) assumptions&lt;/h1&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Joint normal distribution of random effects&lt;/li&gt;
&lt;li&gt;Normally distributed residual&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;Constant variance over time&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;Random effects &lt;span class=&#34;math inline&#34;&gt;\(\pm U_{0j}\)&lt;/span&gt; and residual &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{ij}\)&lt;/span&gt; are uncorrelated and have a mean of zero&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Some of these we can relax, some of these are not too bad if we violate, some of these we cannot escape. A solution, to many of these standard assumptions is to change the model. The model that we are presenting is basic in that it is all defaults.&lt;/p&gt;
&lt;div id=&#34;data-generating-process-dgp&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data generating process (DGP)&lt;/h2&gt;
&lt;p&gt;Our standard assumption is that the DV comes from a data generating process that results in normal distributions. This does not mean that it needs to result in an observed normal distribution. Instead, the default of assuming an Gaussian DGP is practical: it is robust against violations and the alternatives are sometimes harder to justify.&lt;/p&gt;
&lt;p&gt;If you think you have a non-Gaussian DGP (like a Poisson or a negative binomial if you are using some sort of count data) you will need to use a different estimation technique. You can do this somewhat with the package we will be working with primarily, lme4. However, the BRMS package – which uses Bayesian estimation – has many more possibilities: geometric, log normal, weibull, exponential, gamma, Beta, hurdle Poisson/gamma/negative binomial, zero inflated beta/Poisson/negative binomial, cumulative. We will fit some of these later in the semester. Currently, however, assume we are working with&lt;br /&gt;
&lt;span class=&#34;math inline&#34;&gt;\({Y}_{ij} \sim \mathcal{N}(0, \sigma^{2})\)&lt;/span&gt;. Altering the assumed DGP will alter the assumptions we have.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;estimation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Estimation&lt;/h1&gt;
&lt;p&gt;Maximum likelihood estimation. Uses a likelihood function that describes the probability of observing the sample data as a function of the parameters. Attempts to maximize the function through an iterative process. Because it is iterative, it might fail.&lt;/p&gt;
&lt;p&gt;There are fixed effects as well as random effects we need to count for. Maximum likelihood takes our assumptions about the model (normally distributed residuals, etc) and creates probability densities for each parameters. For example, based on certain fixed effects and sd of random effects, how likely is it that person x has a slope of z? The algorithm looks at the full sample to see how likely different parameters are, spits back the most likely, and gives you a number to show how likely they are (compared to others). This is akin to saying you rolled 10 dice, 5 came up as 2s. How likely is this dice fair? But instead of fair vs not fair it gives a likelihood to certain possibilities (e.g., a 2 comes up at 25%, 50% 75% rates).&lt;/p&gt;
&lt;p&gt;Restricted maximum likelihood (REML) vs Full Maximum likelihood (ML). Will give you similar parameters, the differences are in the standard errors. REML is similar to dividing by N - 1 for SE whereas ML is similar to dividing by N.&lt;/p&gt;
&lt;p&gt;Differences account for the fact that fixed effects are being estimated simultaneously with the variance parameters in ML. Estimates of the variance parameters assume that the fixed effects estimates are known and thus does not account for uncertainty in these estimates.&lt;/p&gt;
&lt;p&gt;REML accounts for uncertainty in the fixed effects before estimating residual variance. REML attempts to maximize the likelihood of the residuals whereas ML maximizes the sample data. REML can be thought of as an unbiased estimate of the residual variance.&lt;/p&gt;
&lt;p&gt;REML is good for small sample size both N and group. However, if you use REML you should be careful in testing fixed effects against each other (more down below). Deviances tests for fixed effects should be done with ML, but only random effects with REML. ML can also look at random effects too.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;testing-significance-adapted-from-ben-bolker&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Testing significance (adapted from Ben Bolker)&lt;/h1&gt;
&lt;p&gt;4 Methods for testing single parameters
From worst to best:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Wald Z-tests.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Wald t-tests&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Easy to compute - test statistic over standard error However, they are asymptotic standard error approximations, assuming both that (1) the sampling distributions of the parameters are multivariate normal and that (2) the sampling distribution of the log-likelihood is (proportional to) χ2.&lt;/p&gt;
&lt;p&gt;The above two are okay to do for single parameter estimates of fixed effects. But beware that a) degrees of freedom calculations are not straightforward and b) the assumptions for random effects are be hard to meet.&lt;/p&gt;
&lt;div id=&#34;quick-aside-p-values-are-not-included&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Quick aside: P values are not included&lt;/h2&gt;
&lt;p&gt;Authors of the package we will be using first lme4 are not convinced of the utility of the general approach of testing with reference to an approximate null distribution. In general, it is not clear that the null distribution of the computed ratio of sums of squares is really an F distribution, for any choice of denominator degrees of freedom. While this is true for special cases that correspond to classical experimental designs (nested, split-plot, randomized block, etc.), it is apparently not true for more complex designs (unbalanced, GLMMs, temporal or spatial correlation, etc.).&lt;/p&gt;
&lt;p&gt;tl;dr: it gets messy with more complex models.&lt;/p&gt;
&lt;p&gt;If you really want p values&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# library(lmerTest)&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Likelihood ratio test (also called deviance test).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Markov chain Monte Carlo (MCMC) or parametric bootstrap confidence intervals ( we will get to this later)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;likelihood-ratio-test&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Likelihood ratio test&lt;/h2&gt;
&lt;p&gt;Used for model comparisons (often multiparameter comparisons) and for tests of random effects. REML can only be used if model compared have the same fixed parts and only differ in random. Otherwise ML must be used.&lt;/p&gt;
&lt;p&gt;How much more likely the data is under a more complex model than under the simpler model (these models need to be nested to compare this).&lt;/p&gt;
&lt;p&gt;Log Likelihood (LL) is derived from ML estimation. Logs are used because they are computationally simpler; logs of multiplications are reduced to adding the logs together.&lt;/p&gt;
&lt;p&gt;Larger the LL the better the fit.&lt;/p&gt;
&lt;p&gt;Deviance compares two LLs. Current model and a saturated model (that fits data perfectly). Asks how much worse the current model is to the best possible model. Deviance = -2[LL current - LL saturated]&lt;/p&gt;
&lt;p&gt;LL saturated = 1 for MLMs (probability it will perfectly recapture data). log of 1 is 0. So this term drops out. Deviance = -2(LL current model). AKA -2logL or -2LL&lt;/p&gt;
&lt;p&gt;Can compare two models via subtraction, often referred to as a full and reduced model. Differences is distributed as a chi square with a df equal to how many “constraints” are included. Constraints can be thought of as forcing a parameter to be zero ie removing it.&lt;/p&gt;
&lt;p&gt;Comparing 2 models is called a likelihood ratio test. Need to have:
1. same data
2. nested models (think of constraining a parameter to zero)&lt;/p&gt;
&lt;p&gt;Why work with deviances and not just log likelihoods? Why -2? Why a ratio test when you subtract deviances? Maths. Working with deviances allows us to subtract two from one another, which is equivalent to taking the ratio of likelihoods.&lt;/p&gt;
&lt;p&gt;You can test in r using the same procedure we would to test different regression models.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova(mod.2, mod.2r)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;likelihood-tests-for-random-effects&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Likelihood tests for random effects&lt;/h2&gt;
&lt;p&gt;Not listed in the output because it is harder to do this with variances. Remember variances do not have values below zero and thus the distributions get a wonky quickly. Needs mixture distributions (Cannot be easily done with chi square, for example)&lt;/p&gt;
&lt;p&gt;Can technically do anova comparisons for random effects, though that falls to many similar problems as trying to do a Wald test.&lt;/p&gt;
&lt;p&gt;The sampling distribution of variance estimates is in general strongly asymmetric: the standard error may be a poor characterization of the uncertainty. Thus the best way to handle is to do bootstrapped estimates.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;aic-and-bic&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;AIC and BIC&lt;/h2&gt;
&lt;p&gt;Used when you want to compare non-nested data. Need to have the same data, however.&lt;/p&gt;
&lt;p&gt;AIC (Akaike’s Information Criterion) and the BIC (Bayesian Information Criterion) where “smaller is better.” This is the opposite of LL. As with the other types, these may give you wonky findings depending on some factors as they are related to LLs.&lt;/p&gt;
&lt;p&gt;AIC = 2(number of parameters) + (−2LL)
BIC = ln(n)(number of parameters) + (−2LL)&lt;/p&gt;
&lt;p&gt;BIC penalizes models with more parameters more than AIC does.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;coefficient-of-determination-equivalents&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Coefficient of determination equivalents&lt;/h1&gt;
&lt;p&gt;You want to get a model fit estimate. BIC and AIC are good to compare nested models but they aren’t standardized and thus make comparison across non nested models difficult.&lt;/p&gt;
&lt;p&gt;With MLM models we cannot directly compute R2. Instead we will use pseudo R2. Pseudo R2 is similar to R2 in that it can be thought of as the correlation between your predicted and actual scores. For example, assume we have three waves of data. The intercept is 1, the slope is 2 and time is coded 0,1,2. The predicted scores are: 1, 3, 5. We would then correlate everyone’s first, second and third wave scores with these predicted scores. This correlation squared is pseudo R2, telling us how much variance time explains in our DV.&lt;/p&gt;
&lt;p&gt;Yes, we typically think of this as a measure of variance explained divided by total variance. This is where things get tricky: should you include or exclude variation of different random-effects terms? These are error, but they are modeled in the sense that they are not unexplained. Is the effect size wanted after you are “controlling for” or do you want to talk about total variation. There are similarities here with regards to Eta and Partial Eta squared.&lt;/p&gt;
&lt;p&gt;The general idea is to be upfront about what you are comparing and what is included. Typically this is done with comparing models, much like a hierarchical regression. Taking the difference in variance between model 1 and model 2 and dividing it by model 1 makes it explicit what you are looking at and what you are including or not including.&lt;/p&gt;
&lt;p&gt;E.g,. residual variance in varying intercept model subtracted from growth model divided by intercept only model. This can tell you how much unexplained variance is explained by time.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(sigma(mod.1) - sigma(mod.2)) / sigma(mod.1)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;level-1-predictors-aka-time-varying-covariates-tvcs&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Level 1 predictors AKA Time-varying covariates (TVCs)&lt;/h1&gt;
&lt;p&gt;These are predictors that are assessed at level 1, which repeate. Note that there are some variables that are inherently level 2 (e.g. handedness), some that make sense more as a level 1 (e.g., mood) and some that could be considered either depending on your research question and/or your data (e.g. income). The latter type could concievably change across time (And thus be appropriate for a level 1 variable; tvc) but may not change at the rate of your construct or not be important.&lt;/p&gt;
&lt;p&gt;We will go into these in more depth in further weeks. The two points I want to discuss now are:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;These can be treated as another predictor with the effect of “controlling” for some TVC. Thus the regression coefficents in the model are conditional on this covariate.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For example, if you had group status (yes, no) as your TVC the fixed effect for this would indicate the difference in slope for the two conditions. The slope coefficient would be that average slope (depending on how the covariate is scaled)&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;The level 1 and level 2 models are not that different from previous forms. Here is an example model with a TVC.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;level 1:
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  + \beta_{1j}Time_{ij} + \beta_{2j}Job_{ij} +\varepsilon_{ij} \]&lt;/span&gt;
Level 2:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} +    U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} + U_{1j} \]&lt;/span&gt;
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{2j} = \gamma_{20} \]&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;It is not necessary to specify a random effect for the TVC. Doing so would suggest that the differences in group membership within a person is not the same across people. For example, the effect of jobloss may effect some peoples development but not others.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The key question is whether or not we think the variability across people in their TVC effects are systematic or not. If they are systematic, then maybe it is important to predict them by another variable. Can we go further and also fit a random effects term? This is a tricky issue in that this adds an additional parameter to the random effects and thus increases the number of covariances estimated. Often our data are not large enough to estimate the increased number of parameters and results in non-convergence.&lt;/p&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;The introduction of the TVC can reduce &lt;span class=&#34;math inline&#34;&gt;\(\tau^2_{U_{0j}}\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\tau^2_{U_{1j}}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{ij}\)&lt;/span&gt;. Normal time-invariant covariates only reduce the between person variance in intercept and slope and cannot account for the within person variance.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But, but, because you are adding a new variable that changes the interpretation of the gamma terms, you may actually get increases in your variance components. As a result, it is difficult to directly compare models that have TVCs and those that do not.&lt;/p&gt;
&lt;ol start=&#34;5&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;You may need to seperate between person and within person effects for TVC. This is done through various centering techniques.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Homework is posted! </title>
      <link>/post/homework-is-posted/</link>
      <pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate>
      <guid>/post/homework-is-posted/</guid>
      <description>



</description>
    </item>
    
    <item>
      <title>Week 2</title>
      <link>/lectures/03-growth-curves/</link>
      <pubDate>Thu, 05 Sep 2019 00:00:00 +0000</pubDate>
      <guid>/lectures/03-growth-curves/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#growth-curves&#34;&gt;Growth curves&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#between-person-models-and-cross-sectional-data&#34;&gt;Between person models and cross sectional data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#within-person-models-e.g.-2-level-models&#34;&gt;Within person models e.g., 2-level models&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#thinking-about-random-effects&#34;&gt;Thinking about random effects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#random-effects&#34;&gt;Random effects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#empty-model-equation&#34;&gt;Empty model equation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#putting-it-together&#34;&gt;Putting it together&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#visualize-what-you-are-doing&#34;&gt;Visualize what you are doing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#icc&#34;&gt;ICC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-time&#34;&gt;Adding time&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#what-does-this-look-like-graphically&#34;&gt;What does this look like graphically?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-a-random-slope&#34;&gt;Adding a random slope?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#individual-level-random-effects&#34;&gt;Individual level random effects&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#calculation-of-individual-level-random-effects&#34;&gt;Calculation of individual level random effects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#how-are-these-random-effects-calculated&#34;&gt;How are these random effects calculated?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#random-effect-decomposition&#34;&gt;Random effect decomposition&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;growth-curves&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Growth curves&lt;/h1&gt;
&lt;div id=&#34;between-person-models-and-cross-sectional-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Between person models and cross sectional data&lt;/h2&gt;
&lt;p&gt;You already know this, but it gives us a chance to review regression&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{i} = b_{0} + b_{1}X_{1} + b_{2}X_{2} + b_{3}X_{3}+... +\epsilon_{i} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \hat{Y}_{i} = b_{0} + b_{1}X_{1} + b_{2}X_{2} + b_{3}X_{3}+... \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Parameters are considered fixed where one regression value corresponds to everyone. I.e., that association between X1 and Y is the same for everyone.&lt;/p&gt;
&lt;p&gt;Each person has a Y, denoted by the subscript i, and each has a residual associated with them, also designated by i.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(readr)
example &amp;lt;- read_csv(&amp;quot;~/Box/5165 Applied Longitudinal Data Analysis/ALDA/example copy.csv&amp;quot;)
example$ID &amp;lt;- as.factor(example$ID)
# you can find the data on my github at: https://github.com/josh-jackson/ALDA/example%20copy.csv&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets look at some data. These data examine older adults who came into a study up to six times over a six year period. Multiple cognitive, psychiatric and imaging assessments were done. Let’s look at functional connectivity network called SMN7.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Attaching packages ───────────────────────────────────────────────────────────────────────── tidyverse 1.2.1.9000 ──&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ✔ ggplot2 3.2.1           ✔ dplyr   0.8.3      
## ✔ tibble  2.1.3           ✔ stringr 1.4.0      
## ✔ tidyr   0.8.99.9000     ✔ forcats 0.4.0      
## ✔ purrr   0.3.2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Conflicts ───────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
gg1 &amp;lt;- ggplot(example,
   aes(x = week, y = SMN7)) + geom_point() + stat_smooth(method = &amp;quot;lm&amp;quot;)   
print(gg1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/03-Growth-curves_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;What happens if we run a regression?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;regression &amp;lt;- lm(SMN7 ~ week, data = example)
summary(regression)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = SMN7 ~ week, data = example)
## 
## Residuals:
##       Min        1Q    Median        3Q       Max 
## -0.099294 -0.039929 -0.005938  0.032715  0.169885 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept) 0.100161   0.005261  19.039   &amp;lt;2e-16 ***
## week        0.004087   0.002563   1.595    0.112    
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 0.05562 on 214 degrees of freedom
##   (9 observations deleted due to missingness)
## Multiple R-squared:  0.01174,    Adjusted R-squared:  0.007124 
## F-statistic: 2.543 on 1 and 214 DF,  p-value: 0.1123&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;within-person-models-e.g.-2-level-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Within person models e.g., 2-level models&lt;/h2&gt;
&lt;p&gt;We saw this last time where we can think of everyone being run in a separate regression model. Here the lines connect the dots of the same people across time.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
gg2 &amp;lt;- ggplot(example,
   aes(x = week, y = SMN7, group = ID)) + geom_point() + stat_smooth(method = &amp;quot;lm&amp;quot;, se = FALSE)   

gg3 &amp;lt;- gg2 +  stat_smooth(data = example, aes(x = week, y = SMN7, group=1, colour=&amp;quot;#990000&amp;quot;), method = &amp;quot;lm&amp;quot;, size = 3, se=FALSE) + theme(legend.position = &amp;quot;none&amp;quot;)
print(gg3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/03-Growth-curves_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Each person has multiple assessments, so we need to distinguish between people and their assessments. In normal regression we wouldn’t think about this as everyone datapoint is assumed to be independent. However, this is not the case here. Failing to distinguish would lead to violation of independence, an important assumption of the standard regression model.&lt;/p&gt;
&lt;p&gt;As seen in the graph above, what we have now is both individual level slopes as well as an average level slope. The average level slope is going to be the average of the individual level slopes, which will look like our average slope ignoring all dependencies. Same for the intercept.&lt;/p&gt;
&lt;p&gt;One way to do this is to run separate regressions for each person. Then we could just pool (or average) together where people start and how much they change to get the average intercept (starting value) and trajectory (how much people change). We will see later that this is a somewhat poor approach.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## Joining, by = &amp;quot;ID&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;regressions &amp;lt;- example2 %&amp;gt;% 
  group_by(ID) %&amp;gt;% 
  do(tidy(lm(SMN7 ~ week, data = .)))

head(regressions)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
## # Groups:   ID [3]
##   ID    term        estimate std.error statistic  p.value
##   &amp;lt;fct&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1 67    (Intercept)  0.0921    0.0161       5.72   0.0292
## 2 67    week         0.00662   0.00657      1.01   0.420 
## 3 75    (Intercept)  0.126   NaN          NaN    NaN     
## 4 75    week         0.00771 NaN          NaN    NaN     
## 5 87    (Intercept)  0.0787  NaN          NaN    NaN     
## 6 87    week        -0.0227  NaN          NaN    NaN&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition to the average intercept and the average trajectory there is also the amount of variation around each of these estimates. Do people tend to change the same? Are there individual differences in the initial assessment?&lt;/p&gt;
&lt;p&gt;This type of meaningful variation is lost when we have a between subjects only model that ignores the individual level. This variation will be called Random Effects (or variance estimates in SEM).&lt;/p&gt;
&lt;p&gt;[Side note: note how some people do not have se estimates for their regression coefficients. The reason for this will impact our ability to fit longitudinal models later on.]&lt;/p&gt;
&lt;p&gt;There is another important source of variation different from standard regression models. The within-subjects error that can be seen in the below graph. If we did not take people into account and just collapsed across people to get a between subjects assessment of change, this error would be confounded with individual differences in change. We will discuss this error more in depth later, but one way to think about our goal is to utilize our repeated assessments to make better predictions. A way to do that is to create additional buckets of explained variance, resulting in a smaller bucket of unexplained variance.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;example3 &amp;lt;- example2 %&amp;gt;% 
  filter(ID == &amp;quot;67&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg4 &amp;lt;-  ggplot(example3, aes(x = week, y = SMN7, group = ID)) +  geom_point() + stat_smooth(method = &amp;quot;lm&amp;quot;)

gg4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/03-Growth-curves_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div id=&#34;thinking-about-random-effects&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Thinking about random effects&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&#34;random-effects&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Random effects&lt;/h3&gt;
&lt;p&gt;Within subjects variability in either starting value or slope/trajectory is referenced in terms of random effects. How do we represent this in our equation? Easy, we just say that the typical regression parameters we have are not the same for everyone – that they are random (in contrast to fixed).&lt;/p&gt;
&lt;p&gt;In general, when would we want to use random effects? If there is some sort of selection (random or not) of many possible values of the predictor (e.g., stimuli are 3 random depression drugs, three semi random chosen levels of a drug). With longitudinal data this is (random) people.&lt;/p&gt;
&lt;p&gt;Side bar: Even in situations where these levels are not random (eg working with U.S. states) it is still useful to use MLM and we still call them random effects. To be consistent with language, random here can refer to as random from the population average, not randomly selected. When talking about “random effects” you can mean either of these definitions (and a few more). Luckily we can mostly ignore these semantic issues.&lt;/p&gt;
&lt;p&gt;What is necessary for modeling random effects? For longitudinal models, there needs to be multiple assessments per your grouping category (people, schools, neighborhoods, trials).&lt;/p&gt;
&lt;p&gt;We are assuming these random effects are sampled from some population and thus vary from group to group (or person to person). This means that your coefficients (like traditional regression coefficients) are estimates of some population parameter and thus have error associated with them. This error is not like like a standard residual, which represents error for your overall model. Nor is it like the standard error for a point estimate. Random effects can best be thought of as deviation of individual regression lines from the group regression line (though it technically is not this).&lt;/p&gt;
&lt;p&gt;To facilitate the multiple assessments per person we will now use both i and j subscripts. We will see that the random effects are part of the overall error term in the model. Counterintuitively, the main focus of these types of models will be the fixed effects, with less attention paid to the random effects. That said, the random effects are necessary to account for dependency in the data. One can think about these models as normal fixed effects regressions, with the random effects there to account for the longitudinal nature of the data. They are made up of a number of standard regression equations, each for a single individual. Doing so side steps the trouble of having correlated errors, and thus allows us to interpret our findings without concern.&lt;/p&gt;
&lt;p&gt;To facilitate adding random effects to our model it is helpful to think about two “levels” to our regression equation. We are going to put a regression equation within our regression equation. (Que Xzhibit joke). The first level will be the within-person model, in that it described how people differ across time. The second level will be the between person level. Note that these do not correspond to fixed or random effects. Instead they can be thought to model either within person differences or between person differences. Mastering thinking at these two levels will help make sense of these MLM models.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;empty-model-equation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Empty model equation&lt;/h3&gt;
&lt;p&gt;Let’s start with the most basic model and then expand from there.&lt;/p&gt;
&lt;p&gt;Level 1 - within person
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  +\varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that we have multiple responses per individual j, noted with an i to refer to specific times.&lt;/p&gt;
&lt;p&gt;Also note that the intercept has a subscript. In typical regression it does not. This suggests that not everyone has the same intercept.&lt;/p&gt;
&lt;p&gt;The residuals at this level are thought of as measurement error OR as something that can be explained by time varying predictors.&lt;/p&gt;
&lt;p&gt;Level 2 - between person
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + U_{0j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2 takes the intercept (or other parameter) at level 1 and breaks it down into an equation for each individual, j. An overall group average (the gamma) and a residual term specific to deviation around the intercept (see below).&lt;/p&gt;
&lt;p&gt;And two variance components:
1. a random effect of the intercept
&lt;span class=&#34;math display&#34;&gt;\[ {U}_{0j} \sim \mathcal{N}(0, \tau_{00}^{2})  \]&lt;/span&gt;
The subscript of the &lt;span class=&#34;math inline&#34;&gt;\(U_{0j}\)&lt;/span&gt; refers to the number of the parameter where 0 is the intercept, 1 is the first regression coefficient, and so on. The second refers to the individual, j. So &lt;span class=&#34;math inline&#34;&gt;\(U_{0j}\)&lt;/span&gt; refers to the intercept whereas &lt;span class=&#34;math inline&#34;&gt;\(U_{1j}\)&lt;/span&gt; would refer to the random effect of the first regression coefficient.&lt;/p&gt;
&lt;p&gt;The &lt;span class=&#34;math inline&#34;&gt;\(U_{0j}\)&lt;/span&gt; random effect is said to be normally distributed with a mean of zero and a variance of &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;the residual error term
&lt;span class=&#34;math display&#34;&gt;\[ {R}_{ij} \sim \mathcal{N}(0, \sigma^{2})  \]&lt;/span&gt;
Much like in normal regression there is an error term for all of the variation we cannot account for. What is unique here is that we took that normal variation and split it into two components. One that is attributable to variation around the intercept &lt;span class=&#34;math inline&#34;&gt;\({U}_{0j}\)&lt;/span&gt; and a catch all residual.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Technically this is not a growth model, nor one that is inherently longitudinal. However, it does serve as a nice starting point to identify random effects.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;putting-it-together&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Putting it together&lt;/h3&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \gamma_{00} + U_{0j}  + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;visualize-what-you-are-doing&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Visualize what you are doing&lt;/h3&gt;
&lt;p&gt;Imagine the raw data plotted without knowing person j, how would &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{i}\)&lt;/span&gt; be calculated?&lt;/p&gt;
&lt;p&gt;Now think about the data plotted again but with knowing each person has their own intercept. How would &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{ij}\)&lt;/span&gt; be calculated?&lt;/p&gt;
&lt;p&gt;Finally, how is &lt;span class=&#34;math inline&#34;&gt;\(U_{0j}\)&lt;/span&gt; calculated?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;icc&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;ICC&lt;/h3&gt;
&lt;p&gt;If the ICC is greater than zero, we are breaking standard regression assumptions.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\frac{U_{0j}}{U_{0j}+ \varepsilon_{ij}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Is defined as % variation between over total variance.&lt;/p&gt;
&lt;p&gt;ICC can also be interpreted as the average (or expected) correlation within a nested group, in this case a person. On other words, the ICC is the correlation between any person’s repeated measures (technically residuals).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;adding-time&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Adding time&lt;/h2&gt;
&lt;p&gt;Here is the basic growth model where our predictor is a time variable&lt;/p&gt;
&lt;p&gt;Level 1:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  + \beta_{1j}X_{ij} + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note how similar this looks like to a normal regression equation. Again, the differences are due to those pesky subscripts. Like before, think of this as a normal regression equation at the level of a person. Each person would have one of these equations with, in addition to a unique Y, X and residual, a unique &lt;span class=&#34;math inline&#34;&gt;\(\beta_{0}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\beta_{1}\)&lt;/span&gt;. Look above to those individual regressions we did at the start of this section.&lt;/p&gt;
&lt;p&gt;Level 2:&lt;br /&gt;
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2 takes the parameters at level 1 and decomposes them into a fixed component that reflects that average and then the individual deviations around that fixed effect. &lt;span class=&#34;math inline&#34;&gt;\(U_{0j}\)&lt;/span&gt; is not error in the traditional sense. It describes how much variation there is around that parameter. Do some people start higher while some start lower, for example.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The new level 2 term refers to the first predictor in the level 1 regression equation ie the slope. This slope is fixed in that the level 2 equation only has a gamma term and no U residual term.&lt;/p&gt;
&lt;p&gt;Putting it together:
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \gamma_{00} + \gamma_{10} (X_{1j})+ U_{0j}  + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that in computing a single individuals Y, it depends on the two fixed effects, the Xj, and the random effect for the intercept.&lt;/p&gt;
&lt;div id=&#34;what-does-this-look-like-graphically&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;What does this look like graphically?&lt;/h3&gt;
&lt;p&gt;And how does this differ from the random intercept model?&lt;/p&gt;
&lt;p&gt;Can you draw out the sources of error? The random effects for each participant? The fixed effects?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;adding-a-random-slope&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Adding a random slope?&lt;/h3&gt;
&lt;p&gt;What happens when we add a random slope?
Level 1:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  + \beta_{1j}X_{1j} + \varepsilon_{ij} \]&lt;/span&gt;
Level 2:&lt;br /&gt;
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + U_{0j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{1j} = \gamma_{10} + U_{1j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Putting it together:
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \gamma_{00} + \gamma_{10}(X_{ij})+ U_{0j} + U_{1j}(X_{ij}) + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Can think of a persons score divided up into a fixed component as well as the random component.&lt;/p&gt;
&lt;p&gt;These random effects are likely related to one another. For example, if someone starts high on a construct they are then less likely to increase across time. This negative correlation can be seen in the residual structure, where the random effects are again normally distributed with a mean of zero, but this time one must also consider covariance in addition to variance.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \begin{pmatrix} {U}_{0j} \\ {U}_{1j} \end{pmatrix}
\sim \mathcal{N} \begin{pmatrix} 
  0,     &amp;amp; \tau_{00}^{2} &amp;amp; \tau_{01}\\ 
  0, &amp;amp; \tau_{01} &amp;amp; \tau_{10}^{2}
\end{pmatrix} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that it is possible to have a different error structures, one where there is no relationship between the intercept and the slope, for example. We will discuss this more later in the semester. Right now just know that the default is to have correlated random effects.&lt;/p&gt;
&lt;p&gt;We also have the within subject variance term that accounts for deviations that are not accounted for by time variable and other level 1 predictors.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {R}_{ij} \sim \mathcal{N}(0, \sigma^{2})  \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that it is possible to model these level 1 residuals with different structures. This specification implies that there is no correlation across an individuals residuals, once you account for level 1 predictors (ie growth trajectories). Having a specific level 1 autoregressive or other type of pattern is common in other treatments of longitudinal models (panel models) but is not necessary with growth models (but possible).&lt;/p&gt;
&lt;p&gt;This is the basic format of the growth model. It will be expanded later on by adding variables to the level 1 model and to the level 2 model. Adding to the level 1 model is only possible with repeated variables.&lt;/p&gt;
&lt;p&gt;Level 1 regression coefficients are added to the level 2 model. These coefficients are decomposed into a fixed effect, a random effect (possibly), and between person predictors. As with any regression model, each of these only have a single error term.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;individual-level-random-effects&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Individual level random effects&lt;/h2&gt;
&lt;div id=&#34;calculation-of-individual-level-random-effects&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Calculation of individual level random effects&lt;/h3&gt;
&lt;p&gt;Random effects are often thought in terms of variance components. We can see this if we think of individual level regressions for each person where we then have a mean and a variance for both the intercept or the slope. The greater the variance around the intercept and the slope means that not everyone starts at the same position and not everyone changes at the same rate.&lt;/p&gt;
&lt;p&gt;If you want to look at a specific person’s random effect you can think of it as a deviation from the fixed effect where subject 6’s intercept can be thought of as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{06} = \gamma_{00} \pm U_{06}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;e.g 2.2 = 3 - .8&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-are-these-random-effects-calculated&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;How are these random effects calculated?&lt;/h3&gt;
&lt;p&gt;It isn’t as straightforward as calculating a slope for each person and then using the difference between that slope and the average slope. Instead, the estimates are partially pooled towards the overall mean of the sample, the fixed effect. We do this to get a better estimate of the parameters, the same way that using regression to predict y-hat given an X is better than binning X and calculating y-hat. More information = better.&lt;/p&gt;
&lt;p&gt;Why not full pooling ie give everyone the same slope? Because it ignores individual differences in change. Often individual differences in (intraindividual) change is what we care about.&lt;/p&gt;
&lt;p&gt;The result is that the variance of the change trajectories (using MLM) will be smaller than the variance of the fitted linear models. Trajectories are “regressed” towards the average trajectory under the assumption that extreme scores are extreme because of (measurement) error, not that people are actually extreme.&lt;/p&gt;
&lt;p&gt;Can think about this in terms of creating an average for your intercept. Do you want the average to be the grand mean average, ignoring group? Do you want it to be the person average, ignoring that some people have more data points and thus are better assessed? No right answer, so maybe lets meet in the middle? This is sometimes called an empirical Bayes estimate.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;random-effect-decomposition&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Random effect decomposition&lt;/h3&gt;
&lt;p&gt;Think of the original total variance in a scatter plot of our DVs. Adding random effects takes that variance and trims it down.&lt;/p&gt;
&lt;p&gt;The intercept only MLM separates it into a level 1 variance (which at this stage is treated as error) and a level 2 random intercept variance.&lt;/p&gt;
&lt;p&gt;Creating a random slopes model takes the Level 1 residual variance and creates a new “pile” of explained or accounted for variance.&lt;/p&gt;
&lt;p&gt;We can then further explain the variance or reduce the pile by predictors at level 1 and level 2. Our goal isn’t necessarily to explain all of the variance but it is helpful to reduce the unexplained variance &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{ij}\)&lt;/span&gt; to improve model fit.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>homework #1</title>
      <link>/homeworks/homework-1/</link>
      <pubDate>Thu, 05 Sep 2019 00:00:00 +0000</pubDate>
      <guid>/homeworks/homework-1/</guid>
      <description>


&lt;p&gt;Answer the questions below using your own data (for question 1) and the dataset from this file for the remaining questions:&lt;a href=&#34;https://raw.github.com/josh-jackson/ALDA/master/Hw1&#34; class=&#34;uri&#34;&gt;https://raw.github.com/josh-jackson/ALDA/master/Hw1&lt;/a&gt; If you have your own longitudinal data, please feel free to use that instead.&lt;/p&gt;
&lt;p&gt;If using the provided dataset note that we are looking at depression across 5 waves during college. Waves are signified by a letter at the start of the variable name, starting with A, then B, then C, etcetera. Not all waves collected depression during college.&lt;/p&gt;
&lt;p&gt;Please email your answers via a) an Rmd file and b) a pdf to: &lt;a href=&#34;mailto:Homewor.dk7huzwn6n5aohka@u.box.com&#34; class=&#34;email&#34;&gt;Homewor.dk7huzwn6n5aohka@u.box.com&lt;/a&gt; If you are using your own data please also attach the dataset.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Create a codebook with an actual dataset you are working with (it does not need to be longitudinal). Feed it into R to change variable names.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Take a wide dataset (such as the provided one) and make it long&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run separate linear models on all of the participants subjects (a basic regression). What is the average intercept, the average slope?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now run a mlm/lmer model with only a random intercept. What is the ICC? Interpret.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Introduce a fixed slope term. What is the difference in interpretation for the fixed effects estimates in this estimate and the previous? Of the residual standard error?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run an additional model with a random slope. How does this change compare to the previous fixed slope model? Should you keep the random slope or not?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Interpret the correlation between the slope and the intercept.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a density plot of the random effects from your final model.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Workshop #2</title>
      <link>/workshops/workshop-2/</link>
      <pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate>
      <guid>/workshops/workshop-2/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#tidyr&#34;&gt;tidyr&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#wide-and-long-form&#34;&gt;Wide and Long form&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lme4&#34;&gt;lme4&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#how-to-calculate-icc&#34;&gt;How to calculate ICC?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exploring-beyond-the-summary&#34;&gt;Exploring beyond the summary&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#what-do-the-random-effects-look-like&#34;&gt;what do the random effects look like?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-time-to-the-mlm&#34;&gt;Adding time to the MLM&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#fixed-slope&#34;&gt;Fixed slope&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#random-slope&#34;&gt;Random slope&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testing-models&#34;&gt;Testing models&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#why-treating-time-is-so-important&#34;&gt;Why treating time is so important&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#random-effects&#34;&gt;Random effects&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#calculation-of-random-effect-confidence-interval&#34;&gt;Calculation of random effect confidence interval&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-simulations-to-get-better-estimates-of-confidence-around-our-estimates&#34;&gt;Using simulations to get better estimates of confidence around our estimates&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#caterpillar-plots&#34;&gt;Caterpillar plots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#density-of-individual-random-effects&#34;&gt;Density of individual random effects&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#comparing-to-a-standard-linear-model&#34;&gt;Comparing to a standard linear model&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#comparing-models&#34;&gt;Comparing models&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#predictions-and-prediction-intervals&#34;&gt;Predictions and prediction intervals&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#predictions-and-prediction-intervals-1&#34;&gt;Predictions and prediction intervals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;tidyr&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;tidyr&lt;/h1&gt;
&lt;div id=&#34;wide-and-long-form&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Wide and Long form&lt;/h2&gt;
&lt;p&gt;Depending on what type of analysis you want to perform you may need to restructure your data. I recommend the combination of tidyr and dplyr (among others) to restructure and manage your dataframes. The first decision you need to make is whether you want your data structured in a long or a wide format. There are multiple names to refer to these two types: multivariate vs univariate, person-level vs person-period, etc but they all refer to the same idea. How to structure your data depends on both what level of analysis (individual, dyad, household) and what type of analyses (MLM/SEM). Typically our focus is on individuals.&lt;/p&gt;
&lt;p&gt;Wide form is common among non-longitudinal data. It has one line per individual with all of their repeated measures in the same row, each with some name to distinguish which assessment wave the data came from. In general, this format is used for SEM.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 4
##      ID ext_1 ext_2 ext_3
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1     4     4     4
## 2     2     6     5     4
## 3     3     4     5     6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In contrast, long format has a row per observation. Thus, participants likely have many rows, each one referring to a different assessment wave. There are fewer variables in this format which makes organization somewhat easier. Thus this has been referred to as “Tidy” data. Graphing with ggplot is facilitated when using tidy data such as being in the long format.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 3
##      ID  time   ext
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1     1     4
## 2     1     2     4
## 3     1     3     4
## 4     2     1     6
## 5     2     2     5
## 6     2     3     4
## 7     3     1     4
## 8     3     2     5
## 9     3     3     6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How do you go back and forth? We use the tidyr package! As of a few months ago, you would use the gather and the spread functions. Now these are being phased out and are being replaced by pivot_longer and pivot_wider. The functions work similar but the newer ones are a little more intuitive both in terms of remembering the correct function name as well as well adding more bells and whistles.&lt;/p&gt;
&lt;p&gt;Gather and pivot_longer goes from wide to long.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyr)

wide_to_long &amp;lt;- wide %&amp;gt;% 
  gather(ext_1:ext_3,key = &amp;quot;time&amp;quot;, value = &amp;quot;ext&amp;quot;) 
wide_to_long&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 3
##      ID time    ext
##   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1 ext_1     4
## 2     2 ext_1     6
## 3     3 ext_1     4
## 4     1 ext_2     4
## 5     2 ext_2     5
## 6     3 ext_2     5
## 7     1 ext_3     4
## 8     2 ext_3     4
## 9     3 ext_3     6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyr)

wide_to_long.p &amp;lt;- wide %&amp;gt;% 
  pivot_longer(-ID, names_to = &amp;quot;time&amp;quot;, values_to = &amp;quot;ext&amp;quot;) 
wide_to_long.p&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 3
##      ID time    ext
##   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1 ext_1     4
## 2     1 ext_2     4
## 3     1 ext_3     4
## 4     2 ext_1     6
## 5     2 ext_2     5
## 6     2 ext_3     4
## 7     3 ext_1     4
## 8     3 ext_2     5
## 9     3 ext_3     6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the similarities. The key in all three is to 1. identify which columns need to be reshaped. Here is it all of them besides ID. 2. we need to name the newly created variable that consists of the old column names (here time). 3. we need to name what those values represent (here levels of extraversion)&lt;/p&gt;
&lt;p&gt;The separate function could be used to get only the assessment wave number. This might be useful when combining data together or for creating a common time metric for everyone.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;wide_to_long2 &amp;lt;- wide_to_long %&amp;gt;% 
  separate(time, into = c(&amp;quot;omit&amp;quot;, &amp;quot;wave&amp;quot;), sep = &amp;quot;_&amp;quot;, convert = TRUE) %&amp;gt;%
  dplyr::select(-omit) %&amp;gt;% 
  arrange(ID)
wide_to_long2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 3
##      ID  wave   ext
##   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1     1     4
## 2     1     2     4
## 3     1     3     4
## 4     2     1     6
## 5     2     2     5
## 6     2     3     4
## 7     3     1     4
## 8     3     2     5
## 9     3     3     6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Note that the seperate function will identify non numeric characters and use that to seperate the values. You can omit the sep = function to check yourself. &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One issue that comes up here is that we have differing dates for each assessment. Ideally we would like to utilize that extra information.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 7
##      ID ext_1 ext_2 ext_3 date_1 date_2  date_3 
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;  
## 1     1     4     4     4 1/1/10 5/1/10  8/1/10 
## 2     2     6     5     4 1/6/10 4/10/10 9/1/10 
## 3     3     4     5     6 1/8/10 4/25/10 9/13/10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How do we fix it? The same way we would with multiple variables we want to convert. Wave, along with ID helps us keep track of what variables go with which person at which time. Together, the two serve as a unique identifier. To better understand the code go through each line to see what the intervening data frame looks like.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;long.date &amp;lt;- wide.date %&amp;gt;% 
  gather(-ID, key = &amp;quot;time&amp;quot;, value = &amp;quot;value&amp;quot;) %&amp;gt;% 
  separate(time, into = c(&amp;quot;variable&amp;quot;, &amp;quot;wave&amp;quot;)) %&amp;gt;% 
  spread(variable,value) 
long.date&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 4
##      ID wave  date    ext  
##   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;
## 1     1 1     1/1/10  4    
## 2     1 2     5/1/10  4    
## 3     1 3     8/1/10  4    
## 4     2 1     1/6/10  6    
## 5     2 2     4/10/10 5    
## 6     2 3     9/1/10  4    
## 7     3 1     1/8/10  4    
## 8     3 2     4/25/10 5    
## 9     3 3     9/13/10 6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One difficulty of creating a wave variable is whether or not the variables are named in a manner such that 1) assessment wave is easily identifiable (e.g. does _a always refer to the first wave whereas _b always refer to the second?) and 2) if that is consistent across variables. Having a wave identifier for your variables is important/necessary. Having an easily selected one (ie at the end of the variable name, hopefully separated by an underscore or a period). If assessment wave separators are embedded within the variable name it will be harder to covert your data. Often, variable data is attached at the end of a name such as SWB_4 to refer to the fourth item in a scale. This may obscure wave identification as in SWB_A_4. A similar naming problem can occur with multiple reports e.g,. SWB_4_parent. I recommend putting wave identification last. The difficulties become partly moot when working in long format (read: entering data in) as opposed to wide. This also becomes moot when stored in a separate dataset. This is another reason why you should use codebooks!&lt;/p&gt;
&lt;p&gt;In the above code we used spread to go from long to wide as a means of creating a long dataset where there were multiple variables. Technically this is not a tidy dataset in that it comprises of both long and wide information, but it is the typical format used for MLM analyses.&lt;/p&gt;
&lt;p&gt;Going from long to wide uses spread or pivot_wider function. We will utilize this when converting our MLM models to SEM models, but try the code below to see what happens.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;long_to_wide &amp;lt;- long %&amp;gt;% 
  spread(time, ext)
long_to_wide&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 4
##      ID   `1`   `2`   `3`
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1     4     4     4
## 2     2     6     5     4
## 3     3     4     5     6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this is technically the dataframe format that we want. The problem is that our variable names are numeric. This often causes problems. When working with tibbles use backticks ’ to refer to the column e.g., select(‘1’). I’d recode into a more usable variable name.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;lme4&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;lme4&lt;/h1&gt;
&lt;p&gt;The basic function we will work with is lmer from the lme4 package&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(lme4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: Matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;Matrix&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &amp;#39;package:tidyr&amp;#39;:
## 
##     expand, pack, unpack&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The package was developed to be similar to the lm function. The code will be similar to the formula for the combined model&lt;/p&gt;
&lt;p&gt;Code for empty/null/intercept only model&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lmer(Y ~ 1 + (1 | subjects), data=example)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Level 1
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \beta_{0j}  +\varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Level 2
&lt;span class=&#34;math display&#34;&gt;\[ {\beta}_{0j} = \gamma_{00} + U_{0j} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Combined
&lt;span class=&#34;math display&#34;&gt;\[ {Y}_{ij} = \gamma_{00} + U_{0j}  + \varepsilon_{ij} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1 is the way to reference the intercept. All additional fixed effects go outside the parentheses. Inside the parentheses are the random effects and residual terms. To the right of the vertical line is our level 1 residual term, which references the grouping variable. In this case, as with almost all longitudinal work, is the subject ID. To the left of the vertical line is the random effects we want to estimate. Right now this estimates only one random effect, one for the intercept.&lt;/p&gt;
&lt;p&gt;It is possible to suppress a random intercept by putting a zero instead of a 1. If you do not put anything there the 1 is implied.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lmer(y ~ 1 + time + (1 + time | subjects), data=data)

lmer(y ~ time + (time | subjects), data=data)
# both are equivalent&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;example&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod.1 &amp;lt;- lmer(SMN7 ~ 1 + (1 | ID), data=example)
summary(mod.1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: SMN7 ~ 1 + (1 | ID)
##    Data: example
## 
## REML criterion at convergence: -714.1
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.1575 -0.4728 -0.0232  0.4512  3.2750 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  ID       (Intercept) 0.001823 0.04270 
##  Residual             0.001302 0.03608 
## Number of obs: 225, groups:  ID, 91
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept) 0.106972   0.005106   20.95&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;how-to-calculate-icc&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;How to calculate ICC?&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;0.001823/(0.001823 + 0.001302)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.58336&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;exploring-beyond-the-summary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Exploring beyond the summary&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class(mod.1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;lmerMod&amp;quot;
## attr(,&amp;quot;package&amp;quot;)
## [1] &amp;quot;lme4&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;what-do-the-random-effects-look-like&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;what do the random effects look like?&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sjPlot)
plot_model(mod.1, type = &amp;quot;re&amp;quot;, sort.est = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Workshops/2019-09-04-workshop-2_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(ranef(mod.1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $ID
##       (Intercept)
## 6   -0.0597240676
## 29  -0.0101119688
## 34  -0.0103698893
## 36  -0.0035902640
## 37  -0.0082433829
## 48   0.0455797808
## 53  -0.0222710793
## 54  -0.0066548052
## 58  -0.0060624543
## 61  -0.0271347235
## 66  -0.0123359896
## 67  -0.0026491341
## 69   0.0348398944
## 71  -0.0486040243
## 74   0.0484338355
## 75   0.0224228634
## 76  -0.0021583228
## 78   0.0224780927
## 79  -0.0054325535
## 80  -0.0194707993
## 81   0.0712662731
## 82   0.0053695094
## 85  -0.0532215425
## 86  -0.0388885304
## 87  -0.0387411472
## 89  -0.0208712287
## 91   0.0123812011
## 92  -0.0078125821
## 93   0.0430219016
## 94  -0.0543390588
## 96   0.0233440081
## 97  -0.0497003277
## 98  -0.0432302582
## 99   0.0104394983
## 101  0.0508032394
## 102 -0.0104344307
## 103 -0.0206130188
## 104 -0.0482473609
## 105 -0.0478231980
## 106 -0.0028045239
## 110  0.0418641247
## 112 -0.0109089622
## 114 -0.0549314098
## 115 -0.0013505715
## 116  0.0062422910
## 120  0.0300499418
## 122  0.0793976365
## 125  0.0532803435
## 127 -0.0105050866
## 129 -0.0448207025
## 135  0.0406255726
## 136 -0.0364069792
## 137 -0.0444890904
## 140 -0.0153440709
## 141  0.0770651692
## 142  0.0817077387
## 143  0.0072423981
## 144  0.0001680065
## 146 -0.0551006778
## 149 -0.0137965477
## 150  0.0091583792
## 152 -0.0187707293
## 153  0.0490992150
## 155 -0.0233396072
## 156 -0.0218943803
## 159 -0.0488368935
## 160  0.0024524455
## 162  0.0911638809
## 163  0.0155327007
## 165  0.0320764602
## 167 -0.0025217361
## 169  0.0647586755
## 171 -0.0397728293
## 174  0.0259232134
## 182 -0.0154177625
## 187 -0.0581588783
## 189  0.0348767402
## 190 -0.0030744230
## 193  0.0636533019
## 194  0.0099321407
## 201  0.0104848276
## 204  0.0414352908
## 205  0.0353188897
## 208  0.0033367444
## 209 -0.0346144188
## 211  0.0168223034
## 214 -0.0374146988
## 219  0.0564683729
## 222 -0.0262135788
## 223 -0.0228606119
## 229 -0.0484315899&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(coef(mod.1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $ID
##     (Intercept)
## 6    0.04724795
## 29   0.09686005
## 34   0.09660212
## 36   0.10338175
## 37   0.09872863
## 48   0.15255179
## 53   0.08470093
## 54   0.10031721
## 58   0.10090956
## 61   0.07983729
## 66   0.09463602
## 67   0.10432288
## 69   0.14181191
## 71   0.05836799
## 74   0.15540585
## 75   0.12939488
## 76   0.10481369
## 78   0.12945011
## 79   0.10153946
## 80   0.08750121
## 81   0.17823829
## 82   0.11234152
## 85   0.05375047
## 86   0.06808348
## 87   0.06823087
## 89   0.08610079
## 91   0.11935322
## 92   0.09915943
## 93   0.14999392
## 94   0.05263296
## 96   0.13031602
## 97   0.05727169
## 98   0.06374176
## 99   0.11741151
## 101  0.15777525
## 102  0.09653758
## 103  0.08635900
## 104  0.05872465
## 105  0.05914882
## 106  0.10416749
## 110  0.14883614
## 112  0.09606305
## 114  0.05204060
## 115  0.10562144
## 116  0.11321430
## 120  0.13702196
## 122  0.18636965
## 125  0.16025236
## 127  0.09646693
## 129  0.06215131
## 135  0.14759759
## 136  0.07056503
## 137  0.06248292
## 140  0.09162794
## 141  0.18403718
## 142  0.18867975
## 143  0.11421441
## 144  0.10714002
## 146  0.05187134
## 149  0.09317547
## 150  0.11613039
## 152  0.08820128
## 153  0.15607123
## 155  0.08363241
## 156  0.08507763
## 159  0.05813512
## 160  0.10942446
## 162  0.19813589
## 163  0.12250471
## 165  0.13904847
## 167  0.10445028
## 169  0.17173069
## 171  0.06719918
## 174  0.13289523
## 182  0.09155425
## 187  0.04881314
## 189  0.14184875
## 190  0.10389759
## 193  0.17062532
## 194  0.11690415
## 201  0.11745684
## 204  0.14840730
## 205  0.14229090
## 208  0.11030876
## 209  0.07235760
## 211  0.12379432
## 214  0.06955732
## 219  0.16344039
## 222  0.08075844
## 223  0.08411140
## 229  0.05854042&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(mod.1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (Intercept) 
##    0.106972&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How do these relate? Lets calculate ID 6 intercept random effect&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#coef = fixef + raneff

# coef for ID = 6 is 0.04724795  
0.106972 -0.0597240676 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.04724793&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get residuals and fitted scores&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(broom)
example.aug&amp;lt;- augment(mod.1, data = example)


# .fitted    = predicted values
# .resid    = residuals/errors
# .fixed     = predicted values with no random effects&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;adding-time-to-the-mlm&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Adding time to the MLM&lt;/h2&gt;
&lt;div id=&#34;fixed-slope&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Fixed slope&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod.2f &amp;lt;- lmer(SMN7 ~ 1 + year + (1  | ID), data=example)
summary(mod.2f)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: SMN7 ~ 1 + year + (1 | ID)
##    Data: example
## 
## REML criterion at convergence: -675.4
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.2308 -0.4868 -0.0377  0.4542  3.2337 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  ID       (Intercept) 0.001815 0.04261 
##  Residual             0.001300 0.03606 
## Number of obs: 216, groups:  ID, 88
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept) 0.104041   0.005733  18.147
## year        0.001331   0.001755   0.758
## 
## Correlation of Fixed Effects:
##      (Intr)
## year -0.426&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What does this look like graphically?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;random-slope&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Random slope&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod.2 &amp;lt;- lmer(SMN7 ~ 1 + year + (year  | ID), data=example)
summary(mod.2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: SMN7 ~ 1 + year + (year | ID)
##    Data: example
## 
## REML criterion at convergence: -678.1
## 
## Scaled residuals: 
##      Min       1Q   Median       3Q      Max 
## -1.93345 -0.47015 -0.00405  0.46985  2.67965 
## 
## Random effects:
##  Groups   Name        Variance  Std.Dev. Corr
##  ID       (Intercept) 1.688e-03 0.041085     
##           year        5.999e-05 0.007745 0.11
##  Residual             1.114e-03 0.033378     
## Number of obs: 216, groups:  ID, 88
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept) 0.104719   0.005466  19.157
## year        0.000489   0.001913   0.256
## 
## Correlation of Fixed Effects:
##      (Intr)
## year -0.339&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How does the intercept change from the random intercept only model? It may change because the intercept is now conditional on time ie after accounting for time. It is not the predicted outcome when time = 0. You can think of the previous intercept as the grand mean of person means. If our year variable here changed across time then there would be a larger change in the intercept.&lt;/p&gt;
&lt;p&gt;How do you interpret year?&lt;/p&gt;
&lt;p&gt;How did the random effects change?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;testing-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Testing models&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova(mod.2f, mod.2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## refitting model(s) with ML (instead of REML)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Data: example
## Models:
## mod.2f: SMN7 ~ 1 + year + (1 | ID)
## mod.2: SMN7 ~ 1 + year + (year | ID)
##        Df     AIC     BIC logLik deviance  Chisq Chi Df Pr(&amp;gt;Chisq)
## mod.2f  4 -686.93 -673.43 347.46  -694.93                         
## mod.2   6 -685.45 -665.20 348.73  -697.45 2.5248      2      0.283&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Why is there a 2df difference?&lt;/p&gt;
&lt;p&gt;also you can see the non-REML fit info here:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glance(mod.2f)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 6
##    sigma logLik   AIC   BIC deviance df.residual
##    &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;       &amp;lt;int&amp;gt;
## 1 0.0361   338. -667. -654.    -695.         212&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;why-treating-time-is-so-important&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Why treating time is so important&lt;/h3&gt;
&lt;p&gt;Time with a different scale. How do we interpret? And what changes?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;example$year.n &amp;lt;- (example$year - 30)
  
mod.2n &amp;lt;- lmer(SMN7 ~ 1 + year.n + (year.n  | ID), data=example)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in checkConv(attr(opt, &amp;quot;derivs&amp;quot;), opt$par, ctrl =
## control$checkConv, : Model failed to converge with max|grad| = 1.99825 (tol
## = 0.002, component 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(mod.2n)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: SMN7 ~ 1 + year.n + (year.n | ID)
##    Data: example
## 
## REML criterion at convergence: -674.8
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.2053 -0.4841 -0.0423  0.4505  3.2646 
## 
## Random effects:
##  Groups   Name        Variance  Std.Dev.  Corr 
##  ID       (Intercept) 1.001e-03 0.0316327      
##           year.n      1.333e-07 0.0003652 -1.00
##  Residual             1.320e-03 0.0363343      
## Number of obs: 216, groups:  ID, 88
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept) 0.146910   0.050598   2.904
## year.n      0.001432   0.001763   0.812
## 
## Correlation of Fixed Effects:
##        (Intr)
## year.n 0.995 
## convergence code: 0
## Model failed to converge with max|grad| = 1.99825 (tol = 0.002, component 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What happened?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;random-effects&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Random effects&lt;/h2&gt;
&lt;div id=&#34;calculation-of-random-effect-confidence-interval&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Calculation of random effect confidence interval&lt;/h3&gt;
&lt;p&gt;Conveys the predicted range around each fixed effect in which 95% of the sample individuals are predicted to fall.&lt;/p&gt;
&lt;p&gt;95% random effect = fixed effect plus minus 1.96 * random standard deviation&lt;/p&gt;
&lt;p&gt;How to calculate?
1. Intercept &lt;span class=&#34;math display&#34;&gt;\[ \gamma_{00} \pm  1.96  *  \tau_{U_{0j}}  \]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;0.1193933 + (1.96 * 0.240217) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5902186&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;0.1193933 - (1.96 * 0.240217) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.351432&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Slope &lt;span class=&#34;math display&#34;&gt;\[ \gamma_{10} \pm  1.96  *  \tau_{U_{1j}}  \]&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;0.0004891 + (1.96 * 0.007745) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.0156693&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;0.0004891 - (1.96 * 0.007745) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.0146911&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###Individual level random effects&lt;/p&gt;
&lt;p&gt;Are the intercept random effects the same as the model with only the intercept? Why or why not?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(ranef(mod.1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $ID
##       (Intercept)
## 6   -0.0597240676
## 29  -0.0101119688
## 34  -0.0103698893
## 36  -0.0035902640
## 37  -0.0082433829
## 48   0.0455797808
## 53  -0.0222710793
## 54  -0.0066548052
## 58  -0.0060624543
## 61  -0.0271347235
## 66  -0.0123359896
## 67  -0.0026491341
## 69   0.0348398944
## 71  -0.0486040243
## 74   0.0484338355
## 75   0.0224228634
## 76  -0.0021583228
## 78   0.0224780927
## 79  -0.0054325535
## 80  -0.0194707993
## 81   0.0712662731
## 82   0.0053695094
## 85  -0.0532215425
## 86  -0.0388885304
## 87  -0.0387411472
## 89  -0.0208712287
## 91   0.0123812011
## 92  -0.0078125821
## 93   0.0430219016
## 94  -0.0543390588
## 96   0.0233440081
## 97  -0.0497003277
## 98  -0.0432302582
## 99   0.0104394983
## 101  0.0508032394
## 102 -0.0104344307
## 103 -0.0206130188
## 104 -0.0482473609
## 105 -0.0478231980
## 106 -0.0028045239
## 110  0.0418641247
## 112 -0.0109089622
## 114 -0.0549314098
## 115 -0.0013505715
## 116  0.0062422910
## 120  0.0300499418
## 122  0.0793976365
## 125  0.0532803435
## 127 -0.0105050866
## 129 -0.0448207025
## 135  0.0406255726
## 136 -0.0364069792
## 137 -0.0444890904
## 140 -0.0153440709
## 141  0.0770651692
## 142  0.0817077387
## 143  0.0072423981
## 144  0.0001680065
## 146 -0.0551006778
## 149 -0.0137965477
## 150  0.0091583792
## 152 -0.0187707293
## 153  0.0490992150
## 155 -0.0233396072
## 156 -0.0218943803
## 159 -0.0488368935
## 160  0.0024524455
## 162  0.0911638809
## 163  0.0155327007
## 165  0.0320764602
## 167 -0.0025217361
## 169  0.0647586755
## 171 -0.0397728293
## 174  0.0259232134
## 182 -0.0154177625
## 187 -0.0581588783
## 189  0.0348767402
## 190 -0.0030744230
## 193  0.0636533019
## 194  0.0099321407
## 201  0.0104848276
## 204  0.0414352908
## 205  0.0353188897
## 208  0.0033367444
## 209 -0.0346144188
## 211  0.0168223034
## 214 -0.0374146988
## 219  0.0564683729
## 222 -0.0262135788
## 223 -0.0228606119
## 229 -0.0484315899&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(ranef(mod.2))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $ID
##       (Intercept)          year
## 6   -5.657190e-02 -0.0036945459
## 29  -8.481756e-03 -0.0012401120
## 34  -6.559720e-03 -0.0036272361
## 36  -7.107377e-03  0.0047529824
## 37  -7.584156e-03  0.0003779790
## 48   3.760800e-02  0.0079905136
## 53  -1.989445e-02 -0.0015608099
## 54   1.298061e-03 -0.0046572183
## 58   3.763976e-04 -0.0054304028
## 61  -2.523030e-02 -0.0013740463
## 66  -1.692834e-02  0.0022291440
## 67  -4.435808e-03  0.0020525694
## 71  -4.790346e-02  0.0002829010
## 75   2.147451e-02  0.0025670702
## 76  -1.178132e-03  0.0005880005
## 78   1.590422e-02  0.0031440504
## 79  -4.554999e-03  0.0005646937
## 80  -1.789820e-02 -0.0007154790
## 81   5.310404e-02  0.0082155118
## 82   4.163353e-03  0.0008114128
## 85  -5.229368e-02 -0.0013883325
## 86  -3.747004e-02 -0.0020088462
## 87  -3.530494e-02 -0.0042629307
## 89  -1.906497e-02 -0.0008530205
## 91   1.547560e-02 -0.0021933791
## 92  -5.127067e-03 -0.0012825084
## 93   3.779074e-02  0.0055466427
## 94  -5.318192e-02 -0.0005568113
## 96   2.535874e-02 -0.0004379578
## 97  -4.654850e-02 -0.0019515143
## 98  -3.875698e-02 -0.0027541673
## 99   9.785177e-03  0.0016155143
## 101  4.073120e-02  0.0116039230
## 103 -1.910831e-02 -0.0013254022
## 104 -4.656380e-02 -0.0034349757
## 105 -4.532176e-02 -0.0021913974
## 106  4.024883e-05 -0.0015454111
## 110  5.266477e-02 -0.0065630548
## 112 -5.482604e-03 -0.0041413140
## 114 -5.187791e-02 -0.0023737578
## 115 -6.018565e-04  0.0004676209
## 116  7.916722e-03 -0.0002939168
## 120  3.156554e-02  0.0021828094
## 122  7.845607e-02  0.0030220350
## 125  5.565560e-02 -0.0004030572
## 127 -1.035814e-02  0.0009947753
## 129 -4.383714e-02 -0.0011901610
## 135  4.517320e-02 -0.0027851051
## 136 -3.257406e-02 -0.0027536989
## 137 -4.307457e-02 -0.0026649722
## 140 -1.389973e-02 -0.0009470411
## 141  7.828180e-02  0.0011246004
## 142  7.656429e-02  0.0071700560
## 143  8.802167e-03  0.0001782843
## 144  5.023920e-04  0.0007247389
## 146 -5.190868e-02 -0.0030652978
## 149 -1.315714e-02  0.0001913378
## 150  1.329264e-02 -0.0028911814
## 152 -1.719482e-02 -0.0013669192
## 153  4.865193e-02  0.0022929034
## 155 -2.212352e-02 -0.0004931690
## 156 -2.041537e-02 -0.0004522343
## 159 -4.783022e-02 -0.0015435325
## 160  3.459146e-03  0.0001563020
## 162  8.771544e-02  0.0058967120
## 163  1.575853e-02  0.0011486036
## 165  3.244233e-02  0.0013196820
## 167 -5.436807e-04 -0.0009083619
## 169  6.576873e-02  0.0011926808
## 171 -3.475852e-02 -0.0047511867
## 174  2.798144e-02 -0.0004759192
## 182 -5.231973e-03 -0.0081378967
## 187 -5.609959e-02 -0.0019680493
## 189  3.456648e-02  0.0020405469
## 190 -1.620723e-03 -0.0003743333
## 193  5.854085e-02  0.0071786529
## 194  4.241261e-03  0.0066159420
## 201  1.187752e-02 -0.0001340229
## 204  3.799808e-02  0.0055309494
## 205  4.004323e-02 -0.0029413522
## 208  3.040083e-04  0.0043109412
## 209 -3.367017e-02 -0.0004225192
## 211  1.856239e-02 -0.0003192506
## 214 -3.676234e-02 -0.0001666149
## 219  4.541593e-02  0.0143735740
## 222 -1.947934e-02 -0.0063364890
## 223 -1.719018e-02 -0.0051038253
## 229 -4.254994e-02 -0.0060019177&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;using-simulations-to-get-better-estimates-of-confidence-around-our-estimates&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Using simulations to get better estimates of confidence around our estimates&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(broom.mixed)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Registered S3 methods overwritten by &amp;#39;broom.mixed&amp;#39;:
##   method         from 
##   augment.lme    broom
##   augment.merMod broom
##   glance.lme     broom
##   glance.merMod  broom
##   glance.stanreg broom
##   tidy.brmsfit   broom
##   tidy.gamlss    broom
##   tidy.lme       broom
##   tidy.merMod    broom
##   tidy.rjags     broom
##   tidy.stanfit   broom
##   tidy.stanreg   broom&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;broom.mixed&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:broom&amp;#39;:
## 
##     tidyMCMC&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;random_params &amp;lt;- tidy(mod.2,  effects = &amp;quot;ran_vals&amp;quot;, conf.int=TRUE)
head(random_params)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 8
##   effect   group level term        estimate std.error   conf.low conf.high
##   &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1 ran_vals ID    6     (Intercept) -0.0566     0.0181 -0.0920      -0.0212
## 2 ran_vals ID    29    (Intercept) -0.00848    0.0205 -0.0487       0.0317
## 3 ran_vals ID    34    (Intercept) -0.00656    0.0211 -0.0479       0.0348
## 4 ran_vals ID    36    (Intercept) -0.00711    0.0214 -0.0491       0.0349
## 5 ran_vals ID    37    (Intercept) -0.00758    0.0191 -0.0451       0.0299
## 6 ran_vals ID    48    (Intercept)  0.0376     0.0192 -0.0000131    0.0752&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(merTools)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: arm&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: MASS&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;MASS&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:dplyr&amp;#39;:
## 
##     select&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## arm (Version 1.10-1, built: 2018-4-12)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Working directory is /Users/jackson/Box/5165 Applied Longitudinal Data Analysis/ALDA/content/Workshops&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;FEsim(mod.2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term         mean       median          sd
## 1 (Intercept) 0.1044275974 0.1042850907 0.005457383
## 2        year 0.0004525177 0.0005027204 0.001772442&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;re.sim &amp;lt;- REsim(mod.2)
head(re.sim)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   groupFctr groupID        term         mean       median         sd
## 1        ID       6 (Intercept) -0.057295077 -0.056703757 0.01673668
## 2        ID      29 (Intercept) -0.007118853 -0.006761198 0.02127223
## 3        ID      34 (Intercept) -0.009140396 -0.011494305 0.02064953
## 4        ID      36 (Intercept) -0.006757163 -0.006690657 0.02246798
## 5        ID      37 (Intercept) -0.010541813 -0.011421794 0.01927731
## 6        ID      48 (Intercept)  0.037802717  0.037069177 0.01862808&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can be used to create CIs for each individual random effect (and fixed effect). What is the confidence interval around person 6’s intercept estimate compared to person 2000 who has 25 repeated measurements?&lt;/p&gt;
&lt;div id=&#34;caterpillar-plots&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Caterpillar plots&lt;/h3&gt;
&lt;p&gt;Look through these different methods of getting random effects. Note that they are not all exactly the same.&lt;/p&gt;
&lt;p&gt;caterpillar plots&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1 &amp;lt;- plotREsim(re.sim)
p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Workshops/2019-09-04-workshop-2_files/figure-html/unnamed-chunk-35-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;density-of-individual-random-effects&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Density of individual random effects&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1.gg1 &amp;lt;- re.sim %&amp;gt;% 
  filter(term == &amp;quot;(Intercept)&amp;quot;) 

ggplot(p1.gg1, aes(mean)) +
  geom_density()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Workshops/2019-09-04-workshop-2_files/figure-html/unnamed-chunk-36-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1.gg2 &amp;lt;- re.sim %&amp;gt;% 
  filter(term == &amp;quot;year&amp;quot;) 


ggplot(p1.gg2, aes(mean)) +
  geom_density()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Workshops/2019-09-04-workshop-2_files/figure-html/unnamed-chunk-37-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;comparing-to-a-standard-linear-model&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Comparing to a standard linear model&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lm.1 &amp;lt;- lm(SMN7 ~ 1 + year, data = example)
summary(lm.1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = SMN7 ~ 1 + year, data = example)
## 
## Residuals:
##       Min        1Q    Median        3Q       Max 
## -0.099294 -0.039929 -0.005938  0.032715  0.169885 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept) 0.100161   0.005261  19.039   &amp;lt;2e-16 ***
## year        0.004087   0.002563   1.595    0.112    
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 0.05562 on 214 degrees of freedom
##   (9 observations deleted due to missingness)
## Multiple R-squared:  0.01174,    Adjusted R-squared:  0.007124 
## F-statistic: 2.543 on 1 and 214 DF,  p-value: 0.1123&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;comparing-models&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Comparing models&lt;/h3&gt;
&lt;p&gt;LRT&lt;/p&gt;
&lt;p&gt;Parametric bootstrap for CIs&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;confint(mod.1, method=&amp;quot;boot&amp;quot;, nsim=1000)
summary(mod.1)

# uses SDs of random effects
# sigma = residual standard error&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comparing two models. fit the reduced model, then repeatedly simulate from it and compute the differences between the deviance of the reduced and the full model for each simulated data set. Compare this null distribution to the observed deviance difference.&lt;/p&gt;
&lt;p&gt;This procedure is implemented in the pbkrtest package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(pbkrtest)
#pb &amp;lt;- PBmodcomp(mod.2,mod.2r)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;predictions-and-prediction-intervals&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Predictions and prediction intervals&lt;/h2&gt;
&lt;p&gt;Predict function is deterministic and uses only the fixed effects (i.e. does not include random effects in the predictions). It does not do prediction in the typical sense where you are predicting &lt;em&gt;new&lt;/em&gt; individual’s scores.&lt;/p&gt;
&lt;p&gt;Simulate is non-deterministic because it samples random effect values for all subjects and then samples from the conditional distribution. Simulation is needed to create true predictions.&lt;/p&gt;
&lt;div id=&#34;predictions-and-prediction-intervals-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Predictions and prediction intervals&lt;/h3&gt;
&lt;p&gt;Predict function is deterministic and uses only the fixed effects (i.e. does not include random effects in the predictions). It does not do prediction in the typical sense where you are predicting &lt;em&gt;new&lt;/em&gt; individual’s scores.&lt;/p&gt;
&lt;p&gt;Simulate is non-deterministic because it samples random effect values for all subjects and then samples from the conditional distribution. Simulation is needed to create true predictions.&lt;/p&gt;
&lt;p&gt;Short of a fully Bayesian analysis, bootstrapping is the gold-standard for deriving prediction intervals/bands (ie where would a new person score given X), but the time required is typically high.&lt;/p&gt;
&lt;p&gt;In order to generate a proper prediction (for either a new person or a new observation within a person), a prediction must account for three sources of uncertainty in mixed models:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;the residual (observation-level) variance,&lt;/li&gt;
&lt;li&gt;the uncertainty in the fixed coefficients, and&lt;/li&gt;
&lt;li&gt;the uncertainty in the variance parameters for the random effects&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Does so by:
1. extracting the fixed and random coefficients
2. takes n draws from the multivariate normal distribution of the fixed and random coefficients (separately)
3. calculates the linear predictor for each row in newdata based on these draws, and
4. incorporates the residual variation&lt;br /&gt;
then:
5. returns newdata with the lower and upper limits of the prediction interval and the mean or median of the simulated predictions&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(merTools)
# see also their shiny app: shinyMer(mod.1)

PI &amp;lt;- predictInterval(merMod = mod.2, newdata = example, level = 0.9, n.sims = 100, stat = &amp;quot;median&amp;quot;, include.resid.var = TRUE)
head(PI)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          fit        upr          lwr
## 1 0.05212247 0.12016506 -0.003495031
## 2 0.04395705 0.10841778 -0.001844454
## 3 0.04556779 0.09733971 -0.012021541
## 4 0.08374825 0.15930450  0.042491501
## 5 0.09235429 0.16304766  0.023800414
## 6 0.11114066 0.16009238  0.043252164&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nice for bringing in confidence bands around your prediction (And we might use this later)&lt;/p&gt;
&lt;p&gt;Broom offers the fitted (predicted) values already if you just want to plot your trajectory. But note that these are not typical prediction intervals (what happens if you get a new participant with a certain value of X). The bands fit in ggplot are for predicted &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;|X&lt;/p&gt;
&lt;p&gt;Broom offers the fitted (predicted) values already if you just want to plot your trajectory. But note that these are not typical prediction intervals (what happens if you get a new participant with a certain value of X). The bands fit in ggplot are for predicted &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;|X&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;P.gg &amp;lt;- ggplot(example.aug, aes(x= year, y = .fitted)) + geom_point() + stat_smooth(method = &amp;quot;lm&amp;quot;)   

P.gg&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing non-finite values (stat_smooth).&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_point).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Workshops/2019-09-04-workshop-2_files/figure-html/unnamed-chunk-42-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Can also explicitly simulate new data (rather than rely on another function to do so), which will be useful for power calculations later. In the simulated data, the subject means are different from the means in the original data because simulate samples by-subject random effect values using the variance components in the fitted model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim.1&amp;lt;- simulate(mod.2)
head(sim.1)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Workshop #3</title>
      <link>/workshops/workshop-2/</link>
      <pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate>
      <guid>/workshops/workshop-2/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#purrr&#34;&gt;purrr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#background-iteration&#34;&gt;Background: Iteration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-reading&#34;&gt;Data Reading&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#many-subjects-same-variables-example-1&#34;&gt;Many Subjects, Same Variables (Example 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#many-subjects-different-variables-example-2&#34;&gt;Many Subjects, Different Variables (Example 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multiple-waves-same-variables-example-3&#34;&gt;Multiple Waves, Same Variables (Example 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multiple-waves-different-variables-example-4&#34;&gt;Multiple Waves, Different Variables (Example 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multiple-waves-multiple-files-for-same-variables-example-5&#34;&gt;Multiple Waves, Multiple Files for Same Variables (Example 5)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#running-models&#34;&gt;Running Models&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#read-in-data&#34;&gt;Read in Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#clean-data&#34;&gt;Clean Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#descriptives&#34;&gt;Descriptives&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#coding-time&#34;&gt;Coding Time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fit-unconditional-models&#34;&gt;Fit Unconditional Models&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#icc&#34;&gt;ICC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fit-growth-models&#34;&gt;Fit Growth Models&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#model-comparisons&#34;&gt;Model Comparisons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tabling-values&#34;&gt;Tabling Values&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;purrr&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;purrr&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emoriebeck/R-tutorials/master/ALDA/week_3_purrr/week_3_purrr.Rmd&#34; download&gt;Download .Rmd (won’t work in Safari or IE)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/emoriebeck/R-tutorials/tree/master/ALDA/week_3_purrr&#34; target=&#34;_blank&#34;&gt;See GitHub Repository&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#&lt;code&gt;purrr&lt;/code&gt;&lt;br /&gt;
In my opinion, &lt;code&gt;purrr&lt;/code&gt; is one of the most underrated and under-utilized &lt;code&gt;R&lt;/code&gt; packages. It has completely revolutionized my own efficiency and workspace organization, particularly as someone who works with super messy data that comes in a variety of forms.&lt;/p&gt;
&lt;p&gt;In this tutorial, we are going to cover a number of what I believe are the most functional and important applications of &lt;code&gt;purrr&lt;/code&gt; in psychological research. Given the audience, in the first half of the tutorial, I will focus on working with the diverse forms of data that many of you work with, providing examples of how to load, clean, and merge data using &lt;code&gt;purrr&lt;/code&gt;. In the second half, I will focus on how we can use &lt;code&gt;purrr&lt;/code&gt; with longitudinal data analysis when we are working with multiple predictors and outcomes.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;background-iteration&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Background: Iteration&lt;/h1&gt;
&lt;p&gt;Before we get there, though, I think it’s useful to think about when and where we would use &lt;code&gt;purrr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Iteration is everywhere. It underpins much of mathematics and statistics. If you’ve ever seen the &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt; symbol, then you’ve seen (and probably used) iteration.&lt;/p&gt;
&lt;p&gt;It’s also incredibly useful. Anytime you have to repeat some sort of action many times, iteration is your best friend. In psychology, this often means reading in a bunch of individual data files from an experiment, repeating an analysis with a series of different predictors or outcomes, or creating a series of figures.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(psych)
library(knitr)
library(kableExtra)
library(lme4)
library(broom.mixed)
library(plyr)
library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enter &lt;code&gt;for&lt;/code&gt; loops. &lt;code&gt;for&lt;/code&gt; loops are the “OG” form of iteration in computer science. The basic syntax is below. Basically, we can use a for loop to loop through and print a series of things.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;for(i in letters[1:5]){
  print(i)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a&amp;quot;
## [1] &amp;quot;b&amp;quot;
## [1] &amp;quot;c&amp;quot;
## [1] &amp;quot;d&amp;quot;
## [1] &amp;quot;e&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above “loops” through 5 times, printing the iteration letter.&lt;/p&gt;
&lt;p&gt;Essentially, like the &lt;code&gt;apply()&lt;/code&gt;, &lt;code&gt;lapply()&lt;/code&gt;, &lt;code&gt;sapply()&lt;/code&gt;, and &lt;code&gt;mapply()&lt;/code&gt; family of functions, &lt;code&gt;purrr&lt;/code&gt; is meant to be an alternative to iteration (i.e. &lt;code&gt;for&lt;/code&gt; loops) in &lt;code&gt;R&lt;/code&gt;. &lt;code&gt;for&lt;/code&gt; loops are great, but they aren’t as great in &lt;code&gt;R&lt;/code&gt; as they are in other programming languages. In &lt;code&gt;R&lt;/code&gt;, you’re better off vectorizing or building in C++ backends.&lt;/p&gt;
&lt;p&gt;There are a lot of functions in the &lt;code&gt;purrr&lt;/code&gt; package that I encourage you to check out. Today, though, we’ll focus on the &lt;code&gt;map()&lt;/code&gt; family of functions. The breakdown of map functions is pretty intuitive. The basic map function wants two things as input – a list or vector and a function. So the &lt;code&gt;purrr&lt;/code&gt; equivalent of the example above would be:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;map(letters[1:5], print)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a&amp;quot;
## [1] &amp;quot;b&amp;quot;
## [1] &amp;quot;c&amp;quot;
## [1] &amp;quot;d&amp;quot;
## [1] &amp;quot;e&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] &amp;quot;a&amp;quot;
## 
## [[2]]
## [1] &amp;quot;b&amp;quot;
## 
## [[3]]
## [1] &amp;quot;c&amp;quot;
## 
## [[4]]
## [1] &amp;quot;d&amp;quot;
## 
## [[5]]
## [1] &amp;quot;e&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this returns a list, which we may not always want. With &lt;code&gt;purrr&lt;/code&gt;, we can change the kind of output of &lt;code&gt;map()&lt;/code&gt; by adding a predicate, like &lt;code&gt;lgl&lt;/code&gt;, &lt;code&gt;dbl&lt;/code&gt;, &lt;code&gt;chr&lt;/code&gt;, and &lt;code&gt;df&lt;/code&gt;. So in the example above, we may have wanted just the characters to print. To do that we’d call &lt;code&gt;map_chr()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;map_chr(letters[1:5], print)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a&amp;quot;
## [1] &amp;quot;b&amp;quot;
## [1] &amp;quot;c&amp;quot;
## [1] &amp;quot;d&amp;quot;
## [1] &amp;quot;e&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot; &amp;quot;e&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that it also returns the concatenated character vector as well as printing each letter individually (i.e. iteratively).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt; functions can also hand multiple inputs. Often we may need to input multiple pieces of information to a function, similarly to how we work with nested &lt;code&gt;for&lt;/code&gt; loops. In this case, we have &lt;code&gt;map2()&lt;/code&gt; and &lt;code&gt;pmap()&lt;/code&gt; that take additional arguments. &lt;code&gt;map2()&lt;/code&gt; shockingly takes two inputs and &lt;code&gt;pmap()&lt;/code&gt; takes p arguments that you feed in as list (e.g. &lt;code&gt;pmap(list(a, b, c, d), my_fun))&lt;/code&gt;. A simple printing example would be:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;map2_chr(letters[1:5], 1:5, paste)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a 1&amp;quot; &amp;quot;b 2&amp;quot; &amp;quot;c 3&amp;quot; &amp;quot;d 4&amp;quot; &amp;quot;e 5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note here that we can use &lt;code&gt;map2()&lt;/code&gt; and &lt;code&gt;pmap()&lt;/code&gt; with the predicates from above.&lt;/p&gt;
&lt;p&gt;This likely makes little sense at this point, and that’s fine. The examples in the rest of this tutorial should elucidate their usage. The last note I’ll make is that thinking about the structure of your data is going to be very important when using &lt;code&gt;purrr&lt;/code&gt;. To use it effectively, you’ll need your data in specific forms, which will often require data manipulations. It just takes practice.&lt;/p&gt;
&lt;p&gt;Regardless of the programmatic form, iteration is everywhere. It underpins much of mathematics and statistics. If you’ve ever seen the &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt; symbol, then you’ve seen (and probably used) iteration.&lt;/p&gt;
&lt;p&gt;It’s also incredibly useful. Anytime you have to repeat some sort of action many times, iteration is your best friend. In psychology, this could mean reading in a bunch of separate data files (with separate files for different people, variables, waves, etc.) or performing a number of regressions or other statistical tests.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;data-reading&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Data Reading&lt;/h1&gt;
&lt;p&gt;To demonstrate the first case in which I find &lt;code&gt;purrr&lt;/code&gt; useful, we are going to consider a five cases that, in my experience, capture many of the challenges we often face in working with psychological data. In each of these cases, we will use a codebook of the form we discussed in the previous tutorial on codebooks.&lt;/p&gt;
&lt;p&gt;All of these share a similar feature: multiple files. There are a variety of other techniques you could use to get your data into a usable form, such as those below:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
Writing code to load in each file separately (not good).
&lt;/li&gt;
&lt;li&gt;
Copying each data file into one larger data set in Excel (worse)
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But let’s not do that. Let’s use iteration to make our process efficient and transparent.&lt;/p&gt;
&lt;div id=&#34;many-subjects-same-variables-example-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Many Subjects, Same Variables (Example 1)&lt;/h2&gt;
&lt;p&gt;We will start with a data storage format that is very common in experimental studies in various fields of psychology as well as in observational studies of repeated assessments of individuals (i.e. ESM, EMA, etc.).&lt;/p&gt;
&lt;p&gt;For this first example, I’ll show you how this would look with a &lt;code&gt;for&lt;/code&gt; loop before I show you how it looks with &lt;code&gt;purrr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Assuming you have all the data in a single folder and the format is reasonably similar, you have the following basic syntax:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data_path &amp;lt;- &amp;quot;&amp;quot;
files &amp;lt;- list.files(data_path)
data &amp;lt;- list()
for(i in files){
  data[[i]] &amp;lt;- read.csv(i, stringsAsFactors = F)
}
data &amp;lt;- combine(data)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works fine in this simple case, but where &lt;code&gt;purrr&lt;/code&gt; really shines in when you need to make modifications to your data before combining, whether this be recoding, removing missing cases, or renaming variables.&lt;/p&gt;
&lt;p&gt;But first, the simple case of reading data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data_path &amp;lt;- &amp;quot;~/Documents/week_3_purrr&amp;quot;
df1 &amp;lt;- tibble(ID = list.files(sprintf(&amp;quot;%s/data/example_1&amp;quot;, data_path))) %&amp;gt;%
  mutate(path = sprintf(&amp;quot;%s/data/example_1/%s&amp;quot;, data_path, ID),
         data = map(path, read_csv),
         ID = str_remove(ID, &amp;quot;.csv&amp;quot;)) %&amp;gt;%
  unnest(data) %&amp;gt;%
  select(-path)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above creates a list of ID’s from the data path (files named for each person), reads the data in using the &lt;code&gt;map()&lt;/code&gt; function from &lt;code&gt;purrr&lt;/code&gt;, removes the “.csv” from the ID variable, then unnests the data, resulting in a data frame for each person.&lt;/p&gt;
&lt;p&gt;But often, we have variable names that aren’t super informative, so we want to rename them. In this case, we need to use our codebook to give them more informative variable names.&lt;/p&gt;
&lt;p&gt;In this case, where all people have the same variables, it’s easiest to just rename them after unnesting, so the full code would look like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data_path &amp;lt;- &amp;quot;https://github.com/emoriebeck/R-tutorials/raw/master&amp;quot;
(codebook &amp;lt;- sprintf(&amp;quot;%s/ALDA/week_3_purrr/data/codebook_ex1.csv&amp;quot;, data_path) %&amp;gt;% read_csv)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 15 x 2
##    new_name   old_name
##    &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;   
##  1 O_AesSens  O_1     
##  2 E_Assert   E_1     
##  3 N_Depr     N_1     
##  4 N_EmoVol   N_2     
##  5 O_IntCur   O_2     
##  6 C_Org      C_1     
##  7 A_Rspct    A_1     
##  8 C_Rspnbl   C_2     
##  9 A_Cmpn     A_2     
## 10 O_CrtvImag O_3     
## 11 E_EnerLev  E_2     
## 12 C_Prdctv   C_3     
## 13 A_Trust    A_3     
## 14 N_Anxty    N_3     
## 15 E_Scblty   E_3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;old.names &amp;lt;- codebook$old_name
new.names &amp;lt;- codebook$new_name
df1 &amp;lt;- tibble(ID = list.files(sprintf(&amp;quot;%s/data/example_1&amp;quot;, data_path))) %&amp;gt;%
  mutate(path = sprintf(&amp;quot;%s/data/example_1/%s&amp;quot;, data_path, ID),
         data = map(path, read_csv),
         ID = str_remove(ID, &amp;quot;.csv&amp;quot;))%&amp;gt;%
  unnest(data) %&amp;gt;%
  select(ID, old.names) %&amp;gt;%
  setNames(c(&amp;quot;ID&amp;quot;, new.names))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;many-subjects-different-variables-example-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Many Subjects, Different Variables (Example 2)&lt;/h2&gt;
&lt;p&gt;In some cases, participants may have different variables. This could be do to a skip rule in a study or intentionally different variable collection (e.g. in between-person experiments or idiographic work like I do). In this case, we might need to filter or rename variables within our iterative loop.&lt;/p&gt;
&lt;p&gt;In this case, all participants have the same set of core variables but were randomly assigned to complete one additional scale.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df2 &amp;lt;- tibble(ID = list.files(sprintf(&amp;quot;%s/data/example_2&amp;quot;, data_path))) %&amp;gt;%
  mutate(path = sprintf(&amp;quot;%s/data/example_2/%s&amp;quot;, data_path, ID),
         data = map(path, read_csv),
         ID = str_remove(ID, &amp;quot;.csv&amp;quot;))%&amp;gt;%
  unnest(data) &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;multiple-waves-same-variables-example-3&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Multiple Waves, Same Variables (Example 3)&lt;/h2&gt;
&lt;p&gt;In some cases, instead of multiple files for each participant, we collect a single file for all participants across different waves (e.g. using Qualtrics). In this case, we need to index the files a little differently. Instead of reading in files for participants, we need to read in files for waves, which may be named in a variety of ways.&lt;/p&gt;
&lt;p&gt;Here, I’ll start with a simple example of data that were well-managed and nicely named the same except for wave content. This is a good practice to do. I’m in general against modifying data, but I am a fan of changing file &lt;em&gt;names&lt;/em&gt; because I think this actually helps with data management and prevents the need to actually go in and modify information within files.&lt;/p&gt;
&lt;p&gt;These data come from a longitudinal study of personality. We have seven waves, and the variable names for all items are consistent across waves. In this case, our code is almost identical to reading in multiple files for each participant, except that now we have wave info and will need to toss out part of the file names at the end.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;codebook &amp;lt;- sprintf(&amp;quot;%s/ALDA/week_3_purrr/data/codebook_ex3.csv&amp;quot;, data_path) %&amp;gt;% read_csv
old.names &amp;lt;- str_remove_all(codebook$old_name, &amp;quot;[ ]&amp;quot;)
new.names &amp;lt;- codebook$new_name

df3 &amp;lt;- tibble(wave = paste(&amp;quot;T&amp;quot;, 1:7, sep = &amp;quot;&amp;quot;),
              path = sprintf(&amp;quot;%s/ALDA/week_3_purrr/data/example_3/%s.csv&amp;quot;, data_path, wave)) %&amp;gt;%
  mutate(data = map(path, read_csv),
         wave = as.numeric(str_extract_all(wave, &amp;quot;[0-9]&amp;quot;))) %&amp;gt;%
  select(-path) %&amp;gt;%
  unnest(data) %&amp;gt;%
  select(old.names) %&amp;gt;%
  setNames(new.names)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only change from the code for reading in multiple files for participants is that we have “wave” as a variable instead of “ID” and we use the &lt;code&gt;str_extract_all()&lt;/code&gt; function from the &lt;code&gt;stringr&lt;/code&gt; package (part of &lt;code&gt;tidyverse&lt;/code&gt;) to get rid of everything except the numeric wave value.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;multiple-waves-different-variables-example-4&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Multiple Waves, Different Variables (Example 4)&lt;/h2&gt;
&lt;p&gt;Oftentimes, however, we do not have the same variables across waves or they do have the same names across waves. In those cases, we’ll have to do a little extra work to get our data into a form where we can &lt;code&gt;unnest()&lt;/code&gt; them – that is where shared column names will actually be shared.&lt;/p&gt;
&lt;p&gt;We’ll start with the case where we have some additional information (e.g. demographics) in the first wave.&lt;/p&gt;
&lt;p&gt;These data are the same as we used in the previous example except that I changed the names and added demographic information for this example. This means that we have slightly different information in wave one and need a way to match the same variables across waves. We’ll use our codebook to achieve this with little issue!&lt;/p&gt;
&lt;p&gt;However, because of this, we’ll need to use a function that take the year as input, so that we pull the correct variables from the codebook.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;read_fun &amp;lt;- function(Wave){
  old.names &amp;lt;- str_remove_all((codebook %&amp;gt;% filter(wave == &amp;quot;All&amp;quot; | wave == Wave))$old_name, &amp;quot;[ ]&amp;quot;)
  new.names &amp;lt;- (codebook %&amp;gt;% filter(wave == &amp;quot;All&amp;quot; | wave == Wave))$new_name
  
  sprintf(&amp;quot;%s/ALDA/week_3_purrr/data/example_4/T%s.csv&amp;quot;, data_path, Wave) %&amp;gt;%
    read_csv() %&amp;gt;%
    select(old.names) %&amp;gt;%
    setNames(new.names) %&amp;gt;%
    gather(key = item, value = value, -SID)
}

codebook &amp;lt;- sprintf(&amp;quot;%s/ALDA/week_3_purrr/data/codebook_ex4.csv&amp;quot;, data_path) %&amp;gt;% read_csv

df4 &amp;lt;- tibble(wave = 1:7) %&amp;gt;%
  mutate(data = map(wave, read_fun)) %&amp;gt;%
  unnest(data) %&amp;gt;%
  unite(tmp, item, wave, sep = &amp;quot;.&amp;quot;) %&amp;gt;%
  spread(tmp, value) %&amp;gt;%
  gather(key = item, value = value, -SID, -contains(&amp;quot;Dem&amp;quot;)) %&amp;gt;%
  separate(item, c(&amp;quot;item&amp;quot;, &amp;quot;wave&amp;quot;), sep = &amp;quot;[.]&amp;quot;) %&amp;gt;%
  spread(item, value) &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;multiple-waves-multiple-files-for-same-variables-example-5&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Multiple Waves, Multiple Files for Same Variables (Example 5)&lt;/h2&gt;
&lt;p&gt;In other cases, we may have multiple types of files for different waves. Across waves, those variables may be the same or different, but we’ll focus on the case when we largely want the same variables.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;running-models&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Running Models&lt;/h1&gt;
&lt;p&gt;Another really powerful feature of &lt;code&gt;purrr&lt;/code&gt; is keeping your data, models, tables, plots, etc all conveniently indexed together. Often we need to do this for multiple DV’s or predictors, and you may end up with an environment that looks something like &lt;code&gt;E_fit1&lt;/code&gt;, &lt;code&gt;A_fit1&lt;/code&gt;, &lt;code&gt;E_fit2&lt;/code&gt;, &lt;code&gt;A_fit2&lt;/code&gt; and so on. There’s nothing wrong with this. But eventually you’ll want to pull out coefficients, plot results, etc., and it’s easy to make a copy and paste error or name different types of objects inconsistently, which can be difficult both for future you or someone else using your code.&lt;/p&gt;
&lt;p&gt;Before we can learn how to use &lt;code&gt;purrr&lt;/code&gt; for this, we need to understand what a nested data frame is. If you’ve ever worked with a list in R, you are halfway there. Basically a nested data frame takes the normal data frame you are probably familiar with and adds some new features. It still has columns, rows, and cells, but what makes up those cells isn’t restrictred to numbers, strings, or logicals. Instead, you can put essentially anything you want: lists, models, data frames, plots, etc!&lt;/p&gt;
&lt;p&gt;If this sounds scary, it will hopefully become clearer if we use our read in data from above to run, table, and plot some basic longitudinal models of our data.&lt;/p&gt;
&lt;div id=&#34;read-in-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Read in Data&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;codebook &amp;lt;- sprintf(&amp;quot;%s/ALDA/week_3_purrr/data/codebook_ex6.csv&amp;quot;, data_path) %&amp;gt;%
  read_csv %&amp;gt;%
  mutate(old_name = str_to_lower(old_name))

read_fun &amp;lt;- function(Year){
  old.names &amp;lt;- (codebook %&amp;gt;% filter(year == Year | year == 0))$old_name
  new.names &amp;lt;- (codebook %&amp;gt;% filter(year == Year | year == 0))$new_name
  set &amp;lt;- (codebook %&amp;gt;% filter(year == Year))$dataset[1]
  sprintf(&amp;quot;%s/ALDA/week_3_purrr/data/example_6/%s.csv&amp;quot;, data_path, set) %&amp;gt;%
    read_csv %&amp;gt;%
    select(old.names) %&amp;gt;%
    setNames(new.names)
}

(df6 &amp;lt;- tibble(year = 2005:2015) %&amp;gt;%
  mutate(data = map(year, read_fun)) %&amp;gt;%
  select(-year) %&amp;gt;%
  unnest(data) )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 256,663 x 151
##    Procedural__SID Procedural__hou… `Big 5__C_thoro… `Big 5__E_commu…
##              &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;
##  1             901               94                6                4
##  2            1202              124                7                6
##  3            2301              230                7                6
##  4            2304              230                5                7
##  5            2302              230                6                5
##  6            4601              469                6                6
##  7            4701              477                6                6
##  8            4901              493                5                7
##  9            5201              523                7                5
## 10            5202              523                6                5
## # … with 256,653 more rows, and 147 more variables: `Big
## #   5__A_coarse.2005` &amp;lt;dbl&amp;gt;, `Big 5__O_original.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_worry.2005` &amp;lt;dbl&amp;gt;, `Big 5__A_forgive.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_lazy.2005` &amp;lt;dbl&amp;gt;, `Big 5__E_sociable.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_artistic.2005` &amp;lt;dbl&amp;gt;, `Big 5__N_nervous.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_efficient.2005` &amp;lt;dbl&amp;gt;, `Big 5__E_reserved.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_friendly.2005` &amp;lt;dbl&amp;gt;, `Big 5__O_imagin.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_dealStress.2005` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2005` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2005` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2005` &amp;lt;dbl&amp;gt;, `Life
## #   Event__DadDied.2005` &amp;lt;dbl&amp;gt;, `Life Event__Married.2005` &amp;lt;dbl&amp;gt;, `Life
## #   Event__MomDied.2005` &amp;lt;dbl&amp;gt;, `Life Event__MoveIn.2005` &amp;lt;dbl&amp;gt;, `Life
## #   Event__PartDied.2005` &amp;lt;dbl&amp;gt;, `Life Event__SepPart.2005` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2006` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2006` &amp;lt;dbl&amp;gt;, `Life
## #   Event__Divorce.2006` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2006` &amp;lt;dbl&amp;gt;, `Life
## #   Event__Married.2006` &amp;lt;dbl&amp;gt;, `Life Event__MomDied.2006` &amp;lt;dbl&amp;gt;, `Life
## #   Event__MoveIn.2006` &amp;lt;dbl&amp;gt;, `Life Event__PartDied.2006` &amp;lt;dbl&amp;gt;, `Life
## #   Event__SepPart.2006` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2007` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2007` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2007` &amp;lt;dbl&amp;gt;, `Life
## #   Event__DadDied.2007` &amp;lt;dbl&amp;gt;, `Life Event__Married.2007` &amp;lt;dbl&amp;gt;, `Life
## #   Event__MomDied.2007` &amp;lt;dbl&amp;gt;, `Life Event__MoveIn.2007` &amp;lt;dbl&amp;gt;, `Life
## #   Event__PartDied.2007` &amp;lt;dbl&amp;gt;, `Life Event__SepPart.2007` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2008` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2008` &amp;lt;dbl&amp;gt;, `Life
## #   Event__Divorce.2008` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2008` &amp;lt;dbl&amp;gt;, `Life
## #   Event__Married.2008` &amp;lt;dbl&amp;gt;, `Life Event__MomDied.2008` &amp;lt;dbl&amp;gt;, `Life
## #   Event__MoveIn.2008` &amp;lt;dbl&amp;gt;, `Life Event__PartDied.2008` &amp;lt;dbl&amp;gt;, `Life
## #   Event__SepPart.2008` &amp;lt;dbl&amp;gt;, `Big 5__C_thorough.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__E_communic.2009` &amp;lt;dbl&amp;gt;, `Big 5__A_coarse.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_original.2009` &amp;lt;dbl&amp;gt;, `Big 5__N_worry.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_forgive.2009` &amp;lt;dbl&amp;gt;, `Big 5__C_lazy.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__E_sociable.2009` &amp;lt;dbl&amp;gt;, `Big 5__O_artistic.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_nervous.2009` &amp;lt;dbl&amp;gt;, `Big 5__C_efficient.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__E_reserved.2009` &amp;lt;dbl&amp;gt;, `Big 5__A_friendly.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_imagin.2009` &amp;lt;dbl&amp;gt;, `Big 5__N_dealStress.2009` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2009` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2009` &amp;lt;dbl&amp;gt;, `Life
## #   Event__Divorce.2009` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2009` &amp;lt;dbl&amp;gt;, `Life
## #   Event__Married.2009` &amp;lt;dbl&amp;gt;, `Life Event__MomDied.2009` &amp;lt;dbl&amp;gt;, `Life
## #   Event__MoveIn.2009` &amp;lt;dbl&amp;gt;, `Life Event__PartDied.2009` &amp;lt;dbl&amp;gt;, `Life
## #   Event__SepPart.2009` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2010` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2010` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2010` &amp;lt;dbl&amp;gt;, `Life
## #   Event__DadDied.2010` &amp;lt;dbl&amp;gt;, `Life Event__Married.2010` &amp;lt;dbl&amp;gt;, `Life
## #   Event__MomDied.2010` &amp;lt;dbl&amp;gt;, `Life Event__MoveIn.2010` &amp;lt;dbl&amp;gt;, `Life
## #   Event__PartDied.2010` &amp;lt;dbl&amp;gt;, `Life Event__SepPart.2010` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2011` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2011` &amp;lt;dbl&amp;gt;, `Life
## #   Event__Divorce.2011` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2011` &amp;lt;dbl&amp;gt;, `Life
## #   Event__NewPart.2011` &amp;lt;dbl&amp;gt;, `Life Event__Married.2011` &amp;lt;dbl&amp;gt;, `Life
## #   Event__MomDied.2011` &amp;lt;dbl&amp;gt;, `Life Event__MoveIn.2011` &amp;lt;dbl&amp;gt;, `Life
## #   Event__PartDied.2011` &amp;lt;dbl&amp;gt;, `Life Event__SepPart.2011` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2012` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2012` &amp;lt;dbl&amp;gt;, `Life
## #   Event__Divorce.2012` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2012` &amp;lt;dbl&amp;gt;, `Life
## #   Event__NewPart.2012` &amp;lt;dbl&amp;gt;, `Life Event__Married.2012` &amp;lt;dbl&amp;gt;, `Life
## #   Event__MomDied.2012` &amp;lt;dbl&amp;gt;, `Life Event__MoveIn.2012` &amp;lt;dbl&amp;gt;, …&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;clean-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Clean Data&lt;/h2&gt;
&lt;p&gt;Now the data are all loaded in and have been given informative variable names, but we still need to do some data cleaning for the personality data.&lt;/p&gt;
&lt;p&gt;We’ll start by selecting only the personality variables and reverse-scoring them. Then we’ll create composites. To do so, we’ll again use our codebook.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# reverse code
(df6_long &amp;lt;- df6 %&amp;gt;%
  select(Procedural__SID, contains(&amp;quot;Big 5&amp;quot;)) %&amp;gt;%
  gather(key = item, value = value, -Procedural__SID, na.rm = T) %&amp;gt;%
  left_join(codebook %&amp;gt;% select(item = new_name, reverse, mini, maxi)) %&amp;gt;%
  mutate(value = ifelse(reverse == 1, value, 
                        reverse.code(-1, value, mini = mini, maxi = maxi))))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 544,830 x 6
##    Procedural__SID item                   value reverse  mini  maxi
##              &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1             901 Big 5__C_thorough.2005     6       1     1     8
##  2            1202 Big 5__C_thorough.2005     7       1     1     8
##  3            2301 Big 5__C_thorough.2005     7       1     1     8
##  4            2304 Big 5__C_thorough.2005     5       1     1     8
##  5            2302 Big 5__C_thorough.2005     6       1     1     8
##  6            4601 Big 5__C_thorough.2005     6       1     1     8
##  7            4701 Big 5__C_thorough.2005     6       1     1     8
##  8            4901 Big 5__C_thorough.2005     5       1     1     8
##  9            5201 Big 5__C_thorough.2005     7       1     1     8
## 10            5202 Big 5__C_thorough.2005     6       1     1     8
## # … with 544,820 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# create compoistes  
(df6_long &amp;lt;- df6_long %&amp;gt;%
  mutate(item = str_remove(item, &amp;quot;Big 5__&amp;quot;)) %&amp;gt;%
  separate(item, c(&amp;quot;trait&amp;quot;, &amp;quot;item&amp;quot;), sep = &amp;quot;_&amp;quot;) %&amp;gt;%
  separate(item, c(&amp;quot;item&amp;quot;, &amp;quot;year&amp;quot;), sep = &amp;quot;[.]&amp;quot;) %&amp;gt;%
  group_by(Procedural__SID, trait, year) %&amp;gt;%
  summarize(value = mean(value, na.rm = T)) %&amp;gt;%
  ungroup())&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 181,610 x 4
##    Procedural__SID trait year  value
##              &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
##  1             901 A     2005   5   
##  2             901 A     2009   5.33
##  3             901 A     2013   5   
##  4             901 C     2005   5.33
##  5             901 C     2009   3.33
##  6             901 C     2013   6   
##  7             901 E     2005   4   
##  8             901 E     2009   4   
##  9             901 E     2013   4   
## 10             901 N     2005   4   
## # … with 181,600 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;descriptives&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Descriptives&lt;/h2&gt;
&lt;table class=&#34;table&#34; style=&#34;width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;caption&gt;
&lt;span id=&#34;tab:unnamed-chunk-2&#34;&gt;Table 1: &lt;/span&gt;Descriptive Statistics of Study Variables
&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;border-bottom:hidden&#34; colspan=&#34;1&#34;&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;3&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Extraversion
&lt;/div&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;3&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Agreeablness
&lt;/div&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;3&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Conscientiousness
&lt;/div&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;3&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Neuroticism
&lt;/div&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;3&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Openness
&lt;/div&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
Year
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
M
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
SD
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
N
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
M
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
SD
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
N
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
M
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
SD
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
N
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
M
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
SD
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
N
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
M
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
SD
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
N
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
2005
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
5.14
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.17
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10451
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
5.78
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.00
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10451
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
6.21
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.00
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10451
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4.72
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.23
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10451
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4.46
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.28
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10451
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
2009
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
5.09
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.17
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10327
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
5.66
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.01
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10327
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
6.13
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.00
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10327
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4.85
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.23
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10327
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4.36
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.28
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10327
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
2013
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3.71
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
2.08
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
15544
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4.04
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
2.27
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
15544
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4.30
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
2.46
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
15544
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
5.98
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.64
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
15544
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.88
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4.75
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
15544
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;coding-time&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Coding Time&lt;/h2&gt;
&lt;p&gt;It’s important to remember how we code time. There are several ways we can do it. For now, for simplicity, we will create a new wave variable where 2005 = 0, 2009 = 1, and 2013 = 3, but we could make a lot of other choices depending on our goals.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(df6_long &amp;lt;- df6_long %&amp;gt;%
  mutate(wave = as.numeric(mapvalues(year, from = seq(2005, 2013, 4), to = seq(0, 2, 1)))))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 181,610 x 5
##    Procedural__SID trait year  value  wave
##              &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1             901 A     2005   5        0
##  2             901 A     2009   5.33     1
##  3             901 A     2013   5        2
##  4             901 C     2005   5.33     0
##  5             901 C     2009   3.33     1
##  6             901 C     2013   6        2
##  7             901 E     2005   4        0
##  8             901 E     2009   4        1
##  9             901 E     2013   4        2
## 10             901 N     2005   4        0
## # … with 181,600 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s going to get mad later when I run growth models if I keep people with only one wave, so we’re going to remove them now.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(df6_long &amp;lt;- df6_long %&amp;gt;%
  group_by(trait, Procedural__SID) %&amp;gt;%
  filter(n() &amp;gt; 1) %&amp;gt;%
  ungroup())&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 110,935 x 5
##    Procedural__SID trait year  value  wave
##              &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1             901 A     2005   5        0
##  2             901 A     2009   5.33     1
##  3             901 A     2013   5        2
##  4             901 C     2005   5.33     0
##  5             901 C     2009   3.33     1
##  6             901 C     2013   6        2
##  7             901 E     2005   4        0
##  8             901 E     2009   4        1
##  9             901 E     2013   4        2
## 10             901 N     2005   4        0
## # … with 110,925 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;fit-unconditional-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Fit Unconditional Models&lt;/h2&gt;
&lt;p&gt;Now, here we could run separate unconditional growth models for each of the Big 5 like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit0_E &amp;lt;- lmer(value ~ 1 + (1 | Procedural__SID), data = df6_long %&amp;gt;% filter(trait == &amp;quot;E&amp;quot;))
summary(fit0_E)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML [&amp;#39;lmerMod&amp;#39;]
## Formula: value ~ 1 + (1 | Procedural__SID)
##    Data: df6_long %&amp;gt;% filter(trait == &amp;quot;E&amp;quot;)
## 
## REML criterion at convergence: 62339.1
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -5.8959 -0.4997  0.0144  0.5498  3.3758 
## 
## Random effects:
##  Groups          Name        Variance Std.Dev.
##  Procedural__SID (Intercept) 0.7865   0.8868  
##  Residual                    0.5308   0.7286  
## Number of obs: 22187, groups:  Procedural__SID, 8592
## 
## Fixed effects:
##             Estimate Std. Error t value
## (Intercept)  5.11572    0.01078   474.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this would be tedious and prone to error. So instead we will use list columns to do it. We’ll start by using the &lt;code&gt;group_by()&lt;/code&gt; and &lt;code&gt;nest()&lt;/code&gt; functions from &lt;code&gt;dplyr&lt;/code&gt; and &lt;code&gt;tidyr&lt;/code&gt; to put the data for each trait into a cell of our data frame:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(df6_nested &amp;lt;- df6_long %&amp;gt;%
  group_by(trait) %&amp;gt;%
  nest())&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 2
## # Groups:   trait [5]
##   trait           data
##   &amp;lt;chr&amp;gt; &amp;lt;list&amp;lt;df[,4]&amp;gt;&amp;gt;
## 1 A       [22,187 × 4]
## 2 C       [22,187 × 4]
## 3 E       [22,187 × 4]
## 4 N       [22,187 × 4]
## 5 O       [22,187 × 4]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, our data frame is 5 x 2, with the elements in the second column each containing the data frame that corresponds to that trait. This makes it really easy to run our models using the &lt;code&gt;map()&lt;/code&gt; family of unctions from &lt;code&gt;purrr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below, we will add a new column to our data frame that will contain the unconditional model for each trait.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(df6_nested &amp;lt;- df6_nested %&amp;gt;%
  mutate(fit0 = map(data, ~lmer(value ~ 1 + (1 | Procedural__SID), data = .))))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 3
## # Groups:   trait [5]
##   trait           data fit0     
##   &amp;lt;chr&amp;gt; &amp;lt;list&amp;lt;df[,4]&amp;gt;&amp;gt; &amp;lt;list&amp;gt;   
## 1 A       [22,187 × 4] &amp;lt;lmerMod&amp;gt;
## 2 C       [22,187 × 4] &amp;lt;lmerMod&amp;gt;
## 3 E       [22,187 × 4] &amp;lt;lmerMod&amp;gt;
## 4 N       [22,187 × 4] &amp;lt;lmerMod&amp;gt;
## 5 O       [22,187 × 4] &amp;lt;lmerMod&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can see we have a new list column in our data frame called fit0 that contains an S4 class lmerMod, which simply means your growth model. To understand model, I personally find it easiest to visualize it. What this model is telling us is the mean across all observations as well as the between-person variability in that estimate. I find it easiest to plot this. We’ll go over the code for it next week.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/Workshops/week_3_purrr_files/figure-html/unc%20plot%20ex6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;icc&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;ICC&lt;/h2&gt;
&lt;p&gt;If you remember, what we’re often intersted in with the unconditional model is the ICC (relative between v. within variance), so let’s extract that from the models using the &lt;code&gt;ICC()&lt;/code&gt; function from the &lt;code&gt;reghelper&lt;/code&gt; package. In this case, we will use a version of &lt;code&gt;map()&lt;/code&gt; called &lt;code&gt;map_dbl&lt;/code&gt; because we want our result to be a regular numeric column, not a list column.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(df6_nested &amp;lt;- df6_nested %&amp;gt;%
  mutate(ICC = map_dbl(fit0, reghelper::ICC)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 4
## # Groups:   trait [5]
##   trait           data fit0        ICC
##   &amp;lt;chr&amp;gt; &amp;lt;list&amp;lt;df[,4]&amp;gt;&amp;gt; &amp;lt;list&amp;gt;    &amp;lt;dbl&amp;gt;
## 1 A       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.484
## 2 C       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.490
## 3 E       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.597
## 4 N       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.543
## 5 O       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.545&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;fit-growth-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Fit Growth Models&lt;/h2&gt;
&lt;p&gt;What we’re starting to see is that we still have a tidy working environment, but we’re still holding onto a lot of info that we can access with relative ease.&lt;/p&gt;
&lt;p&gt;But before we get to things like pulling info from our models, let’s go ahead and run our basic growth model with and without a random slope.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(df6_nested &amp;lt;- df6_nested %&amp;gt;%
  mutate(fit1 = map(data, ~lmer(value ~ 1 + wave + (1 | Procedural__SID), data = .)),
         fit2 = map(data, ~lmer(value ~ 1 + wave + (wave | Procedural__SID), data = .))))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 6
## # Groups:   trait [5]
##   trait           data fit0        ICC fit1      fit2     
##   &amp;lt;chr&amp;gt; &amp;lt;list&amp;lt;df[,4]&amp;gt;&amp;gt; &amp;lt;list&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;list&amp;gt;    &amp;lt;list&amp;gt;   
## 1 A       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.484 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt;
## 2 C       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.490 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt;
## 3 E       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.597 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt;
## 4 N       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.543 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt;
## 5 O       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.545 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our data frame has expanded to have two more columns.&lt;/p&gt;
&lt;p&gt;Let’s visualize the difference between these two models.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred_fun &amp;lt;- function(m){
  crossing(wave = seq(0, 2, .5), 
           Procedural__SID = m@frame$Procedural__SID) %&amp;gt;%
    mutate(pred = predict(m, newdata = .))
}

subs &amp;lt;- sample(df6_nested$fit1[[1]]@frame$Procedural__SID, 50)
df6_nested %&amp;gt;%
  select(trait, fit1, fit2) %&amp;gt;%
  gather(model, fit, fit1, fit2) %&amp;gt;%
  mutate(model = mapvalues(model, c(&amp;quot;fit1&amp;quot;, &amp;quot;fit2&amp;quot;), c(&amp;quot;Random Intercept&amp;quot;, &amp;quot;Random Intercept + Slope&amp;quot;)),
         pred = map(fit, pred_fun)) %&amp;gt;%
  select(trait, model, pred) %&amp;gt;%
  unnest(pred) %&amp;gt;%
  mutate(Procedural__SID = as.character(Procedural__SID)) %&amp;gt;%
  filter(Procedural__SID %in% subs) %&amp;gt;%
  ggplot(aes(x = wave, y = pred, color = Procedural__SID, group = Procedural__SID)) + 
    geom_line(alpha = .5, size = .25) +
    facet_grid(model ~ trait) +
    theme_classic() +
    theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Workshops/week_3_purrr_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;model-comparisons&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Model Comparisons&lt;/h2&gt;
&lt;p&gt;To decide if we should have a random slope, we typically do nested model comparisons. We can do that here, too. Here, we need to use both fit1 and fit2, so we’ll use the &lt;code&gt;map2()&lt;/code&gt; function from &lt;code&gt;purrr&lt;/code&gt; to take 2 inputs and use the &lt;code&gt;anova()&lt;/code&gt; function to compare them.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(df6_nested &amp;lt;- df6_nested %&amp;gt;%
  mutate(anova1 = map2(fit1, fit2, anova)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 7
## # Groups:   trait [5]
##   trait           data fit0        ICC fit1      fit2      anova1          
##   &amp;lt;chr&amp;gt; &amp;lt;list&amp;lt;df[,4]&amp;gt;&amp;gt; &amp;lt;list&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;list&amp;gt;    &amp;lt;list&amp;gt;    &amp;lt;list&amp;gt;          
## 1 A       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.484 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt; &amp;lt;df[,8] [2 × 8]&amp;gt;
## 2 C       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.490 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt; &amp;lt;df[,8] [2 × 8]&amp;gt;
## 3 E       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.597 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt; &amp;lt;df[,8] [2 × 8]&amp;gt;
## 4 N       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.543 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt; &amp;lt;df[,8] [2 × 8]&amp;gt;
## 5 O       [22,187 × 4] &amp;lt;lmerMod&amp;gt; 0.545 &amp;lt;lmerMod&amp;gt; &amp;lt;lmerMod&amp;gt; &amp;lt;df[,8] [2 × 8]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To see the results, we can do the following:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df6_nested$anova1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## Data: .
## Models:
## .x[[1L]]: value ~ 1 + wave + (1 | Procedural__SID)
## .y[[1L]]: value ~ 1 + wave + (wave | Procedural__SID)
##          Df   AIC   BIC logLik deviance  Chisq Chi Df Pr(&amp;gt;Chisq)
## .x[[1L]]  4 58533 58565 -29263    58525                         
## .y[[1L]]  6 58535 58583 -29261    58523 2.8338      2     0.2425
## 
## [[2]]
## Data: .
## Models:
## .x[[1L]]: value ~ 1 + wave + (1 | Procedural__SID)
## .y[[1L]]: value ~ 1 + wave + (wave | Procedural__SID)
##          Df   AIC   BIC logLik deviance  Chisq Chi Df Pr(&amp;gt;Chisq)   
## .x[[1L]]  4 57394 57426 -28693    57386                            
## .y[[1L]]  6 57389 57437 -28688    57377 9.3688      2   0.009238 **
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## [[3]]
## Data: .
## Models:
## .x[[1L]]: value ~ 1 + wave + (1 | Procedural__SID)
## .y[[1L]]: value ~ 1 + wave + (wave | Procedural__SID)
##          Df   AIC   BIC logLik deviance  Chisq Chi Df Pr(&amp;gt;Chisq)   
## .x[[1L]]  4 62305 62337 -31149    62297                            
## .y[[1L]]  6 62298 62346 -31143    62286 11.531      2   0.003134 **
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## [[4]]
## Data: .
## Models:
## .x[[1L]]: value ~ 1 + wave + (1 | Procedural__SID)
## .y[[1L]]: value ~ 1 + wave + (wave | Procedural__SID)
##          Df   AIC   BIC logLik deviance  Chisq Chi Df Pr(&amp;gt;Chisq)    
## .x[[1L]]  4 66171 66203 -33081    66163                             
## .y[[1L]]  6 66146 66194 -33067    66134 28.585      2  6.207e-07 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## [[5]]
## Data: .
## Models:
## .x[[1L]]: value ~ 1 + wave + (1 | Procedural__SID)
## .y[[1L]]: value ~ 1 + wave + (wave | Procedural__SID)
##          Df   AIC   BIC logLik deviance  Chisq Chi Df Pr(&amp;gt;Chisq)    
## .x[[1L]]  4 67780 67812 -33886    67772                             
## .y[[1L]]  6 67766 67814 -33877    67754 18.507      2  9.579e-05 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tabling-values&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Tabling Values&lt;/h2&gt;
&lt;p&gt;Looks like we have enough slope variance for all traits but Agreeableness to proceed with the random slope models. We’re going to proceed with the random slope models for all traits for consistency.&lt;/p&gt;
&lt;p&gt;The next thing we want to do is actually examine the model coefficients. To do that, I prefer to use the &lt;code&gt;tidy()&lt;/code&gt; function from the &lt;code&gt;broom.mixed&lt;/code&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(df6_nested &amp;lt;- df6_nested %&amp;gt;%
  mutate(tidy = map(fit2, ~tidy(., conf.int = T))))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 8
## # Groups:   trait [5]
##   trait           data fit0      ICC fit1    fit2    anova1      tidy      
##   &amp;lt;chr&amp;gt; &amp;lt;list&amp;lt;df[,4]&amp;gt;&amp;gt; &amp;lt;list&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;list&amp;gt;  &amp;lt;list&amp;gt;  &amp;lt;list&amp;gt;      &amp;lt;list&amp;gt;    
## 1 A       [22,187 × 4] &amp;lt;lmerM… 0.484 &amp;lt;lmerM… &amp;lt;lmerM… &amp;lt;df[,8] [2… &amp;lt;tibble […
## 2 C       [22,187 × 4] &amp;lt;lmerM… 0.490 &amp;lt;lmerM… &amp;lt;lmerM… &amp;lt;df[,8] [2… &amp;lt;tibble […
## 3 E       [22,187 × 4] &amp;lt;lmerM… 0.597 &amp;lt;lmerM… &amp;lt;lmerM… &amp;lt;df[,8] [2… &amp;lt;tibble […
## 4 N       [22,187 × 4] &amp;lt;lmerM… 0.543 &amp;lt;lmerM… &amp;lt;lmerM… &amp;lt;df[,8] [2… &amp;lt;tibble […
## 5 O       [22,187 × 4] &amp;lt;lmerM… 0.545 &amp;lt;lmerM… &amp;lt;lmerM… &amp;lt;df[,8] [2… &amp;lt;tibble […&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have a new column called tidy that contains a data frame. But we want to be able to see those values. This is where &lt;code&gt;purrr&lt;/code&gt; will really shine once again, especially when coupled with the &lt;code&gt;unnest()&lt;/code&gt; from &lt;code&gt;tidyr&lt;/code&gt;. Watch:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df6_nested %&amp;gt;%
  select(trait, tidy) %&amp;gt;%
  unnest(tidy)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 30 x 9
## # Groups:   trait [5]
##    trait effect group term  estimate std.error statistic conf.low conf.high
##    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
##  1 A     fixed  &amp;lt;NA&amp;gt;  (Int…   5.77     0.0107     539.     5.75      5.79  
##  2 A     fixed  &amp;lt;NA&amp;gt;  wave   -0.0576   0.00646     -8.91  -0.0702   -0.0449
##  3 A     ran_p… Proc… sd__…   0.701   NA           NA     NA        NA     
##  4 A     ran_p… Proc… sd__…   0.107   NA           NA     NA        NA     
##  5 A     ran_p… Proc… cor_…  -0.121   NA           NA     NA        NA     
##  6 A     ran_p… Resi… sd__…   0.707   NA           NA     NA        NA     
##  7 C     fixed  &amp;lt;NA&amp;gt;  (Int…   6.22     0.0105     592.     6.20      6.24  
##  8 C     fixed  &amp;lt;NA&amp;gt;  wave   -0.0461   0.00633     -7.29  -0.0586   -0.0337
##  9 C     ran_p… Proc… sd__…   0.699   NA           NA     NA        NA     
## 10 C     ran_p… Proc… sd__…   0.143   NA           NA     NA        NA     
## # … with 20 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is fine, but kind of ugly (I can’t publish this table, and it should be clear right now that I do not like copying and pasting).&lt;/p&gt;
&lt;p&gt;The code below is going to clean this up a bit. See if you can figure out what’s going on:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;terms &amp;lt;- tibble(old = c(&amp;quot;(Intercept)&amp;quot;, &amp;quot;wave&amp;quot;, &amp;quot;sd__(Intercept)&amp;quot;, &amp;quot;sd__wave&amp;quot;,
                        &amp;quot;cor__(Intercept).wave&amp;quot;, &amp;quot;sd__Observation&amp;quot;),
                new = c(&amp;quot;Intercept&amp;quot;, &amp;quot;Slope&amp;quot;, &amp;quot;SD Intercept&amp;quot;, &amp;quot;SD Slope&amp;quot;, &amp;quot;Intercept-Slope Correlation&amp;quot;, &amp;quot;SD Residual&amp;quot;))

(tab &amp;lt;- df6_nested %&amp;gt;%
  select(trait, tidy) %&amp;gt;%
  unnest(tidy) %&amp;gt;% 
  mutate(term = mapvalues(term, from = terms$old, to = terms$new)) %&amp;gt;%
  select(trait, effect, term, estimate, conf.low, conf.high))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 30 x 6
## # Groups:   trait [5]
##    trait effect   term                        estimate conf.low conf.high
##    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;                          &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
##  1 A     fixed    Intercept                     5.77     5.75      5.79  
##  2 A     fixed    Slope                        -0.0576  -0.0702   -0.0449
##  3 A     ran_pars SD Intercept                  0.701   NA        NA     
##  4 A     ran_pars SD Slope                      0.107   NA        NA     
##  5 A     ran_pars Intercept-Slope Correlation  -0.121   NA        NA     
##  6 A     ran_pars SD Residual                   0.707   NA        NA     
##  7 C     fixed    Intercept                     6.22     6.20      6.24  
##  8 C     fixed    Slope                        -0.0461  -0.0586   -0.0337
##  9 C     ran_pars SD Intercept                  0.699   NA        NA     
## 10 C     ran_pars SD Slope                      0.143   NA        NA     
## # … with 20 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We extracted some elements, but we still aren’t quite ready for publication. Let’s do some reshaping so that we have different rows for terms and different columns for traits.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;levs &amp;lt;- paste(rep(c(&amp;quot;E&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;N&amp;quot;, &amp;quot;O&amp;quot;), each = 2), rep(c(&amp;quot;b&amp;quot;, &amp;quot;CI&amp;quot;), 5), sep = &amp;quot;.&amp;quot;)
(tab &amp;lt;- tab %&amp;gt;%
  mutate(sig = ifelse(sign(conf.low) == sign(conf.high), &amp;quot;sig&amp;quot;, &amp;quot;ns&amp;quot;)) %&amp;gt;%
  mutate_at(vars(estimate:conf.high), ~sprintf(&amp;quot;%.2f&amp;quot;, .)) %&amp;gt;%
  mutate_at(vars(conf.low, conf.high), ~ifelse(. == &amp;quot;NA&amp;quot;, &amp;quot;&amp;quot;, .)) %&amp;gt;%
  mutate(CI = ifelse(effect == &amp;quot;fixed&amp;quot;, sprintf(&amp;quot;[%s, %s]&amp;quot;, conf.low, conf.high), &amp;quot;&amp;quot;)) %&amp;gt;%
  mutate_at(vars(estimate, CI), ~ifelse(is.na(sig), .,
              ifelse(sig == &amp;quot;sig&amp;quot;, sprintf(&amp;quot;&amp;lt;strong&amp;gt;%s&amp;lt;/strong&amp;gt;&amp;quot;, .), .))) %&amp;gt;%
  select(trait:term, b = estimate, CI) %&amp;gt;%
  gather(key = est, value = value, b, CI) %&amp;gt;%
  unite(tmp, trait, est, sep = &amp;quot;.&amp;quot;) %&amp;gt;%
  mutate(tmp = factor(tmp, levels = levs)) %&amp;gt;%
  spread(tmp, value))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 12
##   effect  term  E.b   E.CI  A.b   A.CI  C.b   C.CI  N.b   N.CI  O.b   O.CI 
##   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1 fixed   Inte… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str…
## 2 fixed   Slope &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str… &amp;lt;str…
## 3 ran_pa… Inte… -0.20 &amp;quot;&amp;quot;    -0.12 &amp;quot;&amp;quot;    -0.19 &amp;quot;&amp;quot;    -0.28 &amp;quot;&amp;quot;    -0.16 &amp;quot;&amp;quot;   
## 4 ran_pa… SD I… 0.91  &amp;quot;&amp;quot;    0.70  &amp;quot;&amp;quot;    0.70  &amp;quot;&amp;quot;    0.94  &amp;quot;&amp;quot;    0.95  &amp;quot;&amp;quot;   
## 5 ran_pa… SD R… 0.71  &amp;quot;&amp;quot;    0.71  &amp;quot;&amp;quot;    0.68  &amp;quot;&amp;quot;    0.79  &amp;quot;&amp;quot;    0.83  &amp;quot;&amp;quot;   
## 6 ran_pa… SD S… 0.16  &amp;quot;&amp;quot;    0.11  &amp;quot;&amp;quot;    0.14  &amp;quot;&amp;quot;    0.22  &amp;quot;&amp;quot;    0.20  &amp;quot;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have it formatted, but let’s make it pretty using the &lt;code&gt;kable()&lt;/code&gt; function from the &lt;code&gt;knitr&lt;/code&gt; package and the &lt;code&gt;kableExtra&lt;/code&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tab %&amp;gt;%
  mutate(effect = mapvalues(effect, c(&amp;quot;fixed&amp;quot;, &amp;quot;ran_pars&amp;quot;), c(&amp;quot;Fixed&amp;quot;, &amp;quot;Random&amp;quot;))) %&amp;gt;%
  kable(., &amp;quot;html&amp;quot;, escape = F, booktabs = T, 
        col.names = c(&amp;quot;Effect&amp;quot;, &amp;quot;Term&amp;quot;, rep(c(&amp;quot;b&amp;quot;, &amp;quot;CI&amp;quot;), times = 5)),
        align = c(&amp;quot;r&amp;quot;, &amp;quot;r&amp;quot;, rep(&amp;quot;c&amp;quot;,10)),
        caption = &amp;quot;Growth Model Terms for the Big 5&amp;quot;) %&amp;gt;%
  kable_styling(full_width = F) %&amp;gt;%
  collapse_rows(1, valign = &amp;quot;top&amp;quot;) %&amp;gt;%
  add_header_above(c(&amp;quot; &amp;quot; = 2, &amp;quot;Extraversion&amp;quot; = 2, &amp;quot;Agreeablness&amp;quot; = 2, 
                     &amp;quot;Conscientiousness&amp;quot; = 2, &amp;quot;Neuroticism&amp;quot; = 2, &amp;quot;Openness&amp;quot; = 2))&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table&#34; style=&#34;width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;caption&gt;
(#tab:kable ex6)Growth Model Terms for the Big 5
&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;border-bottom:hidden&#34; colspan=&#34;2&#34;&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;2&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Extraversion
&lt;/div&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;2&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Agreeablness
&lt;/div&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;2&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Conscientiousness
&lt;/div&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;2&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Neuroticism
&lt;/div&gt;
&lt;/th&gt;
&lt;th style=&#34;border-bottom:hidden; padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; &#34; colspan=&#34;2&#34;&gt;
&lt;div style=&#34;border-bottom: 1px solid #ddd; padding-bottom: 5px; &#34;&gt;
Openness
&lt;/div&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
Effect
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
Term
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
b
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
CI
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
b
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
CI
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
b
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
CI
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
b
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
CI
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
b
&lt;/th&gt;
&lt;th style=&#34;text-align:center;&#34;&gt;
CI
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;vertical-align: top !important;&#34; rowspan=&#34;2&#34;&gt;
Fixed
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
Intercept
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;5.15&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[5.13, 5.18]&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;5.77&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[5.75, 5.79]&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;6.22&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[6.20, 6.24]&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;4.74&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[4.72, 4.77]&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;4.46&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[4.44, 4.49]&lt;/strong&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
Slope
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;-0.04&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[-0.05, -0.03]&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;-0.06&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[-0.07, -0.04]&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;-0.05&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[-0.06, -0.03]&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;0.08&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[0.07, 0.10]&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;-0.04&lt;/strong&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;strong&gt;[-0.06, -0.03]&lt;/strong&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;vertical-align: top !important;&#34; rowspan=&#34;4&#34;&gt;
Random
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
Intercept-Slope Correlation
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
-0.20
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
-0.12
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
-0.19
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
-0.28
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
-0.16
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
SD Intercept
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.91
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.70
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.70
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.94
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.95
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
SD Residual
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.71
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.71
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.68
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.79
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.83
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
SD Slope
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.16
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.11
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.14
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.22
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
0.20
&lt;/td&gt;
&lt;td style=&#34;text-align:center;&#34;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Welcome to longitudinal data analysis! </title>
      <link>/post/welcome-to-longitudinal-data-analysis/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      <guid>/post/welcome-to-longitudinal-data-analysis/</guid>
      <description>


&lt;p&gt;Please take a look at the syllabus for important class details.&lt;/p&gt;
&lt;p&gt;Any updates or announcements to the class will be found here on the main page. Otherwise, the lectures and workshop pages will where you will spend most of your time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Week 1</title>
      <link>/lectures/02-lda-basics/</link>
      <pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate>
      <guid>/lectures/02-lda-basics/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lda-basics&#34;&gt;LDA basics&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#procedural&#34;&gt;Procedural&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#goals&#34;&gt;Goals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#motivation-terms-concepts&#34;&gt;Motivation, terms, concepts&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#why-longitudinal-what-can-we-ask&#34;&gt;Why longitudinal? What can we ask?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#types-of-change-most-common&#34;&gt;Types of change (most common)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#between-person-versus-within-person-variables&#34;&gt;Between person versus within person variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modeling-frameworks-mlm-sem&#34;&gt;Modeling frameworks: MLM &amp;amp; SEM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#meaningful-time-metric&#34;&gt;Meaningful time metric&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#thinking-through-longitudinal-data-example&#34;&gt;Thinking through longitudinal data example&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#person-level&#34;&gt;Person level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#doing-this-with-mlm-and-sem&#34;&gt;Doing this with MLM (and SEM)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#design-considerations&#34;&gt;Design considerations&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#number-of-assessment-waves&#34;&gt;1. Number of assessment waves&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#measurement&#34;&gt;2. Measurement&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#threats-to-validity&#34;&gt;Threats to validity&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#missing-data&#34;&gt;1. Missing data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#attritionmortality&#34;&gt;2. Attrition/Mortality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#historycohort&#34;&gt;3. History/cohort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#maturation&#34;&gt;4. Maturation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testing&#34;&gt;5. Testing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#selection&#34;&gt;6. Selection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#why-not-rm-anova&#34;&gt;Why not RM ANOVA?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;lda-basics&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;LDA basics&lt;/h1&gt;
&lt;div id=&#34;procedural&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Procedural&lt;/h2&gt;
&lt;p&gt;By virtue of being on this page, you know the class website. You may access all of the code and datasets and everything that is used to create the lectures through my github: &lt;a href=&#34;https://github.com/josh-jackson/ALDA&#34; class=&#34;uri&#34;&gt;https://github.com/josh-jackson/ALDA&lt;/a&gt;. The provided code should be enough but if you want to search farther go for it.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;goals&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Goals&lt;/h2&gt;
&lt;p&gt;This first class is set to orientate you to the world of longitudinal data and MLM models.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;motivation-terms-concepts&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Motivation, terms, concepts&lt;/h2&gt;
&lt;div id=&#34;why-longitudinal-what-can-we-ask&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Why longitudinal? What can we ask?&lt;/h3&gt;
&lt;p&gt;At least 7 reasons:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Identification of intraindividual change (and stability). Do people increase or decrease with time or age. Is this pattern monotonic? Should this best be conceptualized as a stable process or something that is more dynamic? On average how do people change? Ex: people decline in cognitive ability across time.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inter-individual differences in intraindividual change. Does everyone change the same? Do some people start higher but change less? Do some increase while some decrease? Ex: not all people people decline in cognitive ability across time, but some do.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Examine joint relationship among intraindividual change for two or more constructs. If variable X goes up does variable Y also go up across time? Does this always happen or only during certain times? Is this association due to a third variable or does it mean that change occurs for similar reasons? Ex: changes in cognitive ability are associated with changes in health across time.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Determinants of intraindividual change. What are the repeated experiences that can push construct X around. Do these have similar effects at all times? Ex: people declinein cognitive ability across time. Ex: I have better memory compared to other times when I engage in cognitive activities vs times that I do not.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Determinants of interindividual differences in intraindividual change. Do events, background characteristics, interventions or other between person characteristic shape why certain people change while others don’t? Ex: people decline less in cognitive ability across time if tend to do cognitively engaging activities.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inter-individual differences in intraindividual fluctuation and determinants of intraindividual fluctuation. Does everyone vary the same? Why are some more variable than others? Ex: Someone who is depressed fluctuates more in happiness than someone who is not depressed&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Are there different classes/populations/mixtures of intraindividual change? Ex: do people who decrease vs don’t in cognitive ability across time exist as different groups? (Vs construing differences as on a continuum).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;types-of-change-most-common&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Types of change (most common)&lt;/h3&gt;
&lt;p&gt;There are many ways to think of change and stability. We will only have time to go into a few of these types, but it is helpful to think about what type you are interested in when you plan a project or sit down to analyze data. “Change” can mean different things. The above questions you can ask mostly map onto #3 definition of change below.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Differential / rank order consistency/ rank order stability. Goes by many names but in the end it is just a correlation. This is a group/sample/population level variable and indexes the relative standing of a person with regard to the rest of the members in the sample. Does not take into account mean structure. Best used with heterotypic continuity where the construct may be the same but the measurement of the construct changes e.g., childhood IQ or acting out in school versus when you are an adult.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A specialized case of this is ipsative change, which looks at the rank order of constructs within a person. This is not done on a single variable (depression) but on a broad number of them (all PD symptoms). Often uses profiles.&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Mean level/ absolute change. Takes into account mean structure and indexes absolute levels of a construct. A strong assumption is that the construct means (not a pun) the same thing across time. That is, my measure of depression is interpreted the same for a 40 year old and a 90 year old if I want to look at absolute differences between the two ages.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Mean level change is not dependent at all on rank order consistency. Can have no mean level change and high rank order consistency and vice versa.&lt;/p&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Individual differences in change. Rank order and mean level provide an index of change and or stability for the sample. Here this provides an assessment of change for an individual. For example, if it is typical to decline in cognitive ability do some people buck the trend and stay at their past level? Individual differences in change get at both mean level changes as well as the tendency of the sample to show stability. It is the type of change that we will focus on the most.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Structural. Does the construct (or measure) change across time? The assumption for mean level change assumes that the measurement properties stays the same. But maybe it is theoretically interesting to ask whether what you are measuring changes. Examples include practice effects, age effects (cog ability in kids vs adults), differences due to health and life events.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Variance. Does your experiment lead to an increas in variability in response? You may show no mean levels (which is what is looked at in typical t-tests and ANOVAs) but you could see people increase or decrease in their expected range of response.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So how do we refer to ‘change’? Usually it is easier to refer to pictorially or in terms of an equation. Putting a word onto it usually causes some confusion, which is why there are a lot of redundant terms in the literature. All of these might refer to the same thing when used within a model. However, the names of some models use these terms differently and thus can refer to different models or conditions that you are working with. In this class I will try to point out the important differences but you will be fine if you supplement your terms with graphs or equations. Math is the great equalizer.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;between-person-versus-within-person-variables&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Between person versus within person variables&lt;/h3&gt;
&lt;p&gt;Between-person versus within-person are the shortened version of interindividaul differences in change versus intraindividaul differences in change. Refers to across people versus within a particular person. Do you care about how people differ from their previous and future self or do you care about how people differ from other people? (See examples in the 7 types of questions we can ask)&lt;/p&gt;
&lt;p&gt;Often we are interested in modeling both between person and within person variables simultaneously. This is related to Level 1 and Level 2 (for those of you familiar with this terminology). It is helpful to start thinking about what variables you are working with and whether they are within or between person variables. For predictors, it is typically the case that between person effects are constant (between person) variables (e.g., gender) that do not change from assessment to assessment or are only assessed once. In contrast, within person questions are best understood by time varying predictors (within person variables e.g., daily mood) that are assessed more than once.&lt;/p&gt;
&lt;p&gt;We will incorporate both time invariant (between person) and time varying (within person) predictors into our eventual model. In addition to thinking about the types of questions you want to ask it is important to think about what “type” or variables you are working with. Your choice of questions you can ask depends on how often you assess variables or how you conceptualize them.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;modeling-frameworks-mlm-sem&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Modeling frameworks: MLM &amp;amp; SEM&lt;/h3&gt;
&lt;p&gt;In this class (and in the field) two primary techniques are used with longitudinal models: MLM and SEM. At some levels they are completely equivalent. At others, one is better than the other and vice versa.&lt;/p&gt;
&lt;p&gt;MLM/HLM is a simple extension of standard regression models. As a result it is easy to interpret and implement. In terms of longitudinal data it is best suited to run models when the time of measurement differs from person to person (compared to equal intervals). For this class we will use lme4 and brms as our MLM program but there are many others we could use e.g., nlme.&lt;/p&gt;
&lt;p&gt;SEM is related to regression in that regression is a subset of SEM techniques. In other words, an SEM program could run a simple regression analysis.&lt;/p&gt;
&lt;p&gt;The primary advantage of MLM is that you may have assessment waves that vary in length between participants. An assumption of SEM models is that everyone has the same amount of time between assessment waves (though this assumption can be relaxed). MLM is also better suited for complex error structures and complex nesting above and beyond assessments within person. It is also easier to model interactions. Currently, it is easier to do MLM within a Bayesian framework too.&lt;/p&gt;
&lt;p&gt;SEM primary advantage is the ability to account for measurement error via latent assessment of the repeated measures. Other advantages include the ability to model multiple DVs at once, and do so in a flexible manner to look at, for example, the associations between change in one construct and change in the another (though these are also possible with MLMs). Another major advantage is the ability to look at latent groups via latent class or mixture models.&lt;/p&gt;
&lt;p&gt;Bottom line: MLM is probably best suited for “basic” or “standard” growth models. More complex analyses of change with multiple variables would benefit from an SEM approach. This is also an oversimplification.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;meaningful-time-metric&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Meaningful time metric&lt;/h2&gt;
&lt;p&gt;Time is the most important part of a longitudinal analyses. Without some sort of explicit operationalization of time or thought into how you handle time in your analyses you are not conducting longitudinal analyses. The key to interpreting your output is to know how you handled your time variable. What units is it in? Does everyone have the same differences between assessments? Is time something you are explicitly interested in or merely there as a means to collect repeated measures? We will discuss more of these as the semester progresses. Right now however an important distinction is what should the scale of our x-axis variable, time, be in?&lt;/p&gt;
&lt;p&gt;At one level, the distinction is relevant to what is the process that is changing someone? Is it a naturally occurring developmental process? Then maybe age is the best metric. What about tracking child’s cognitive ability, something that might be influenced by level of schooling? Here grade may be more important than age. Another common metric is time in study. This may be useful if you are running an intervention or if you want to put everyone on the same starting metric and then control for nuisance variables like age or schooling level. Similarly, year of study as a prime time candidate may be useful if you are working from panel studies and interested in historical events and or cohort effects. A wave variable (ie study measurement occasion) may be good enough to use as a time metric (though this makes some assumptions about the regularity of assessments both within and across people).&lt;/p&gt;
&lt;p&gt;Depending on your choice of time metric you may see different rates of change and variability in change. For psychological applications the most common would be age and time in study (followed by grades for assessments of kids). Age is nice because it captures a number of developmental processes thought to drive change (maturation, history, time-in-study) but does not identify a single reason. Time in study is the opposite in that it does not index any other type of change but that simplicity aides in testing different reasons for change (e.g, age moderation). Thus choosing one type of time metric will naturally guide the types of questions you are able to address. E.g. if you use age as your time metric you won’t be able to control for age or examine the effects of age as simply as if you used time in study.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;thinking-through-longitudinal-data-example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Thinking through longitudinal data example&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Attaching packages ─────────────────────────── tidyverse 1.2.1.9000 ──&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ✔ tibble  2.1.3           ✔ dplyr   0.8.3      
## ✔ tidyr   0.8.99.9000     ✔ stringr 1.4.0      
## ✔ readr   1.3.1           ✔ forcats 0.4.0      
## ✔ purrr   0.3.2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Conflicts ─────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using some resting state imaging data, lets think about how we can model and think about this data using our current skills (ie standard regression and plotting)&lt;/p&gt;
&lt;p&gt;We defined time as year in study. How would this look if we used age?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg1 &amp;lt;- ggplot(example,
   aes(x = year, y = SMN7, group = ID)) + geom_point()  
print(gg1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_point).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/02-LDA-basics_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The above graph just plots datapoints. Do we have repeated assessments per person? Lets find out.&lt;/p&gt;
&lt;div id=&#34;person-level&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Person level&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg2 &amp;lt;- ggplot(example,
   aes(x = year, y = SMN7, group = ID)) + geom_line()  
gg2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_path).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/02-LDA-basics_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;
Note that some people start at different levels. Some people have more data in terms of assessment points and years. Note that the shape of change isn’t necessarily a straight line.&lt;/p&gt;
&lt;p&gt;We often want to look at this at a per person level to get more info.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg3 &amp;lt;- ggplot(example,
   aes(x = year, y = SMN7, group = ID)) + geom_line() +  geom_point() + facet_wrap( ~ ID)
gg3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_path).&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_point).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/02-LDA-basics_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;
As part of our dataset we have different groups. A question we may have is if they change differently across time. Lets take a look at this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg4 &amp;lt;- ggplot(example,
   aes(x = year, y = SMN7, group = ID)) + geom_line() + facet_grid(. ~ group)
gg4&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_path).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/02-LDA-basics_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We’re not in Kansas anymore - look at the technocolor.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg5 &amp;lt;-  gg2 + aes(colour = factor(ID)) + guides(colour=FALSE) 
gg5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_path).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/02-LDA-basics_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Okay, beside the occular technique, we’re going to need to do something more to address our theoretical questions. Lets look at some random people in the sample and run some regressions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(11)
ex.random &amp;lt;- example %&amp;gt;% 
  dplyr::select(ID) %&amp;gt;% 
  distinct %&amp;gt;% 
  sample_n(10) 

example2 &amp;lt;-
  left_join(ex.random, example)  &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Joining, by = &amp;quot;ID&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg6 &amp;lt;- ggplot(example2,
   aes(x = week, y = SMN7, group = ID)) +  geom_point() + stat_smooth(method=&amp;quot;lm&amp;quot;) + facet_wrap( ~ID)
gg6&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in qt((1 - level)/2, df): NaNs produced

## Warning in qt((1 - level)/2, df): NaNs produced

## Warning in qt((1 - level)/2, df): NaNs produced

## Warning in qt((1 - level)/2, df): NaNs produced

## Warning in qt((1 - level)/2, df): NaNs produced

## Warning in qt((1 - level)/2, df): NaNs produced&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/02-LDA-basics_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Lets look at individual level regressions&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(broom)

regressions &amp;lt;- example2 %&amp;gt;% 
  group_by(ID) %&amp;gt;% 
  do(tidy(lm(SMN7 ~ week, data=.)))

regressions&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 x 6
## # Groups:   ID [10]
##       ID term        estimate std.error statistic  p.value
##    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
##  1    67 (Intercept)  0.0921    0.0161      5.72    0.0292
##  2    67 week         0.00662   0.00657     1.01    0.420 
##  3    75 (Intercept)  0.126   NaN         NaN     NaN     
##  4    75 week         0.00771 NaN         NaN     NaN     
##  5    87 (Intercept)  0.0787  NaN         NaN     NaN     
##  6    87 week        -0.0227  NaN         NaN     NaN     
##  7    99 (Intercept)  0.111     0.0236      4.69    0.0426
##  8    99 week         0.00545   0.0122      0.446   0.699 
##  9   101 (Intercept)  0.111     0.0424      2.62    0.232 
## 10   101 week         0.0421    0.0217      1.94    0.303 
## 11   103 (Intercept)  0.0887  NaN         NaN     NaN     
## 12   103 week        -0.0168  NaN         NaN     NaN     
## 13   105 (Intercept)  0.0465    0.00658     7.06    0.0896
## 14   105 week         0.00122   0.00467     0.261   0.838 
## 15   142 (Intercept)  0.197   NaN         NaN     NaN     
## 16   142 week         0.0130  NaN         NaN     NaN     
## 17   149 (Intercept)  0.0801  NaN         NaN     NaN     
## 18   149 week         0.00497 NaN         NaN     NaN     
## 19   152 (Intercept)  0.0921  NaN         NaN     NaN     
## 20   152 week        -0.0172  NaN         NaN     NaN&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What can we see? Estimates give us an intercept and regression coefficient for each person. Some people increase across time, some decrease. Some we cannot do statistical tests on – why?&lt;/p&gt;
&lt;p&gt;Well that is per person. Lets get the average starting value and change per week&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;regressions %&amp;gt;% 
  group_by(term) %&amp;gt;% 
  summarise(avg.reg = mean(estimate))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 2
##   term        avg.reg
##   &amp;lt;chr&amp;gt;         &amp;lt;dbl&amp;gt;
## 1 (Intercept) 0.102  
## 2 week        0.00244&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets plot the average trend across everyone. Start with a best fit line not taking into account that people have repeated measures.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg7 &amp;lt;-  gg1 &amp;lt;- ggplot(example, aes(x = year, y = SMN7)) + geom_point() + stat_smooth() 
gg7&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## `geom_smooth()` using method = &amp;#39;loess&amp;#39; and formula &amp;#39;y ~ x&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing non-finite values (stat_smooth).&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_point).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/02-LDA-basics_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;That lowess line is a little strange. How about a linear estimate.&lt;/p&gt;
&lt;p&gt;Split up by group&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg8 &amp;lt;-  ggplot(example, aes(x = year, y = SMN7)) + geom_point() + stat_smooth(method = &amp;quot;lm&amp;quot;) + facet_grid(. ~ group)
gg8&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing non-finite values (stat_smooth).&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_point).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/02-LDA-basics_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;But I also want to see the individual slopes, not just the average.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gg9 &amp;lt;- ggplot(example, aes(x = year, y = SMN7, group = ID)) + geom_point(alpha = 0.05) + stat_smooth(method = &amp;quot;lm&amp;quot;, se = FALSE)   

gg10 &amp;lt;- gg9 +  stat_smooth(data = example, aes(x = year, y = SMN7, group=1, color = &amp;quot;black&amp;quot;), method = &amp;quot;lm&amp;quot;, size = 2) + guides(fill=FALSE)


gg11 &amp;lt;- gg10 + facet_grid(.~ group) + theme(legend.position=&amp;quot;none&amp;quot;)

gg11&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing non-finite values (stat_smooth).

## Warning: Removed 9 rows containing non-finite values (stat_smooth).&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 9 rows containing missing values (geom_point).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/Lectures/02-LDA-basics_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;doing-this-with-mlm-and-sem&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Doing this with MLM (and SEM)&lt;/h3&gt;
&lt;p&gt;These regressions and plots are how you should begin to think about longitudinal data analysis. These growth models (the simplest form of longitudinal data analysis) are just a bunch of regressions for each person plus a little extra stuff. MLM is just a fancy regression equation. We want to create a line for everyone. Does someone go up? Does someone go down? On average, do people’s lines indciate that this construct increases or decreases? That is it. Seriously.&lt;/p&gt;
&lt;p&gt;What is different from normal regression? Extra error terms, mostly. For regression, we think of error as existing in one big bucket. For MLMs (and other longitudinal models) we will be breaking up unexplained variance (error) into multiple buckets.&lt;/p&gt;
&lt;p&gt;This is where fixed effects and random effects come into play. We will discuss this more next class, but the gist is that fixed effects are the regression coefficients you are used to. Fixed effects index group level change. Do people decline in memory across time, on average? Random effects vary among individuals (in the longitudinal models we are talking about) and index variation from the group. While most people decline in their memory, does everyone? In other words, an average trajectory will be termed a fixed effect and the random effect indexes how much variability there is around that group level effect. This extra variability we measure through random effects means that we are explaining more variance and thus there is less unexplained variance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;design-considerations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Design considerations&lt;/h2&gt;
&lt;div id=&#34;number-of-assessment-waves&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1. Number of assessment waves&lt;/h3&gt;
&lt;p&gt;Remember high school algebra: two points define a line. But, that assumes we can measure constructs without error. Three assessment points will better define changes in psychological variables. As a default, you need three waves of data to use MLM models. However, some simplifications can be made with MLM. Two wave assessments are mostly better with SEM approaches.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;measurement&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2. Measurement&lt;/h3&gt;
&lt;div id=&#34;scale-of-measurement&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Scale of measurement&lt;/h4&gt;
&lt;p&gt;Measurement is always the basis for good quantiative analysis. Without good measurement you are just spitting into the wind. Standard measurement concerns remain (reliability, dimensionality) but extra concerns exist with longitudinal data.&lt;/p&gt;
&lt;p&gt;What does it mean for categorical variables to change over time? Can you imagine a trajectory for what this is measuring? How would dichotomous responses impact ability to measure change?&lt;/p&gt;
&lt;p&gt;What about ranks, such as in preference for school subjects? What if the class composition changes – what is this assessing? Given that ranks are related such that if I increase someone has to decrease, how does that impact change assessments?&lt;/p&gt;
&lt;p&gt;Can I analyze childhood and adult variables simultaneously if assess the same construct, even though they may be measured differently? How can you measure change in the same construct but with different measures? To assess math ability in 5 year olds you can ask them about addition, can you do that in a sample of 20 year olds? Does that measure continue to assess math ability?&lt;/p&gt;
&lt;p&gt;Often the answer to these is to use a different form of the longitudinal model. In general, the better measured the construct (continuous, not dependent on others, using the same scale) the more complex/sophisticated analysis you can run. Worse measurment leads to simplification both in terms of the models and the types of conclusions you can make.&lt;/p&gt;
&lt;p&gt;As with all of science, everything rests on measurement. Poor measurement results in poor conclusions.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;standardizing&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Standardizing&lt;/h4&gt;
&lt;p&gt;It is standard practice to z-score to get standardized responses. However, it is not straight forward to do so when using longitudinal data. Why would z-scoring your variables be problematic?&lt;/p&gt;
&lt;p&gt;First, if you scale for age, for example, this takes out a potential explanatory variable.&lt;/p&gt;
&lt;p&gt;Second, more worriesome, it also can add error if not everyone is standardized consistently (say if standardization is across age groups and someone just misses a cut). Or if the sample changes due to attrition.&lt;/p&gt;
&lt;p&gt;Third, is that you take away the mean for each assessment such that the expected change across time is zero. We will talk more about solutions to this problem as the semester progresses but the short answer is to avoid or to use SEM.&lt;/p&gt;
&lt;p&gt;While helpful for cross sectional analyses, z-scoring adds in layers of computational and interpretational problems.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;reliability&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Reliability&lt;/h4&gt;
&lt;p&gt;The goal of longitudinal analyses is to understand why some construct changes or stays the same across time. A major difficulty in addressing this goal is whether you are able to accurately assess the construct of interest. One of the key characteristics (but not the only characteristic) is whether or not your assessment would be consistent if you gave an alternative measure or if you retook it immediately after your first assessment. This is known as reliability of measurement. To the extent that your measure is reliable it assesses true score variance as opposed to error variance. The amount of error score variance assessed is important given that error variance will masquerade as change across time given that error can correlate with anything else. The more error in your measurement the more change you will find. Of course this is unreliable change – change that is not true change, just stochastic noise.&lt;/p&gt;
&lt;p&gt;We can think of reliability two ways. First, reliability of the change estimate. This depends on how much error there is in the assessment and the number of waves. These two components are similar to inter item correlation and number of items being the two main components that effect reliability in cross sectional analyses. Increase the number of items (waves) you increase your alpha. Increase the average correlation among items, you increase your alpha. The parallel to average correlation among items is our ability to accurately assess the construct. When comparing a construct across time we examine this with measurement invariance.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;measurement-invariance&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Measurement invariance&lt;/h4&gt;
&lt;p&gt;The second way to think of reliability is in terms of how consistently the measure is assessed across time. Or, do you assess the same construct at each time? What would happen if we looked at change in IQ from 1st grade to 12 grade and used the first grade IQ test at each time? The construct that you assessed at the first wave is likely not the same assessed later.
To test this formally is called measurement invariance and is typically done through SEM. We will talk more about this later in the semester. Until we get there we make a large assumption that what we are measuring now is the same at each wave of assessment.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;threats-to-validity&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Threats to validity&lt;/h2&gt;
&lt;div id=&#34;missing-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1. Missing data&lt;/h3&gt;
&lt;div id=&#34;types-of-missing-data&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Types of missing data&lt;/h4&gt;
&lt;p&gt;On a scale from 1 to you’re completely screwed, how confident are you that the missingness is not related to your study variables?&lt;/p&gt;
&lt;p&gt;Missing completely at random (MCAR) means that the missingness pattern is due entirely to randomness&lt;/p&gt;
&lt;p&gt;Missing at random (MAR) means that there is conditional randomness. Missingness may be due to other variables in the dataset. Pretty standard for longitudinal data.&lt;/p&gt;
&lt;p&gt;Not missing at random (NMAR) means that the missingness is systematic based on the missing values and not associated with measured variables. For example, in a study of reading ability, kids with low reading ability drop out, due to not liking to take tests on reading ability. However, if reading ability is associated with other variables in the model, then this missingness becomes closer in kind to MAR, and thus somewhat less problematic.&lt;/p&gt;
&lt;p&gt;Typically, we make the assumption we are working under MAR and thus we will have unbiased estimates when predictors of missingness are incorporated into the model.&lt;/p&gt;
&lt;p&gt;There are tests to distinguish MAR from NMAR but you cannot distinguish MCAR from MAR because it is based entirely on knowing something that you dont have.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-to-handle-missing-data&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;How to handle missing data&lt;/h4&gt;
&lt;p&gt;Listwise? Nah&lt;/p&gt;
&lt;p&gt;Full information maximum likelihood and other ML approaches? Sure.
Multiple imputation? Cannot hurt. More on these approaches later.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;attritionmortality&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2. Attrition/Mortality&lt;/h3&gt;
&lt;p&gt;Major contributor to missing data&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;historycohort&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3. History/cohort&lt;/h3&gt;
&lt;p&gt;Know that the processes driving change can be due to a specific event or cohort.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;maturation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;4. Maturation&lt;/h3&gt;
&lt;p&gt;Change may occur because of natural processes. Thus if you just follow someone across time they will likely change irregardless of say, if they are in the control group.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;testing&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;5. Testing&lt;/h3&gt;
&lt;p&gt;Having people take the same survey, test or interview multiple times may lead them to respond differently. Does that change result from development or does it result from them being familiar with the test?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;selection&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;6. Selection&lt;/h3&gt;
&lt;p&gt;If you are looking at life events, know that life events are not distributed randomly. Moreover, people who stay in studies and even sign up for studies are different from those that do not. As a result, it is often hard to make internally valid inferences with longitudinal data.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;why-not-rm-anova&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Why not RM ANOVA?&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Cannot handle missing data&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Assumes rate of change is the same for all individuals.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Time is usually done with orthogonal polynomials, making it difficult to interpret or to model non-linear. In other words, you have flexibility on how you want to model time.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accounting for correlation across time uses up many parameters, MLM is more efficient.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Can accommodate differences in time between assessment waves across participants&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Handles various types of predictors - continuous vs nominal &amp;amp; static vs dynamic&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Bottom line: this is an old way of doing these analyses with no upside. Don’t do them.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Workshop Week 1</title>
      <link>/workshops/workshop-1/</link>
      <pubDate>Wed, 14 Aug 2019 00:00:00 +0000</pubDate>
      <guid>/workshops/workshop-1/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#what-are-data&#34;&gt;What Are Data?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#workspace&#34;&gt;Workspace&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#packages&#34;&gt;Packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#codebook&#34;&gt;Codebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data&#34;&gt;Data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#clean-data&#34;&gt;Clean Data&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#recode-variables&#34;&gt;Recode Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reverse-scoring&#34;&gt;Reverse-Scoring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#create-composites&#34;&gt;Create Composites&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bfi-s&#34;&gt;BFI-S&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#life-events&#34;&gt;Life Events&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#descriptives&#34;&gt;Descriptives&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#scale-reliability&#34;&gt;Scale Reliability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#zero-order-correlations&#34;&gt;Zero-Order Correlations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;what-are-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What Are Data?&lt;/h1&gt;
&lt;p&gt;Data are the core of everything that we do in statistical analysis. Data come in many forms, and I don’t just mean &lt;code&gt;.csv&lt;/code&gt;, &lt;code&gt;.xls&lt;/code&gt;, &lt;code&gt;.sav&lt;/code&gt;, etc. Data can be wide, long, documented, fragmented, messy, and about anything else that you can imagine.&lt;/p&gt;
&lt;p&gt;Although data could arguably be more means than end in psychology, the importance of understanding the structure and format of your data cannot overstated. Failure to understand your data could end in improper techniques and flagrantly wrong inferences at worst. This is especially important for longitudinal data.&lt;/p&gt;
&lt;p&gt;In this workshop, we are going to talk data management and basic data cleaning. Other tutorials will go more in depth into data cleaning and reshaping. This tutorial is meant to prepare you to think about those in more nuanced ways and to help you develop a functional workflow for conducting your own research.&lt;/p&gt;
&lt;p&gt;The workshop applies to ALL of your data/projects/analysis, not just longitudinal data. These are practices that will accomplish three goals: 1) efficiently load and leave your data in the right form to be analyzed, 2) have the organization so as to follow what you did and so others can understand you did, and 3. share the data/code/plots/analyses easily and effectively. None of the following are the absolute necessary way to accomplish your data analytic goals. However, we feel that people mostly don’t think through these steps. Hammstringing them later. In other words, if you know an alternative that means you already know what we are trying to convey.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;workspace&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Workspace&lt;/h1&gt;
&lt;p&gt;When I create an &lt;code&gt;rmarkdown&lt;/code&gt; document for my own research projects, I always start by setting up my my workspace. This involves 3 steps:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Packages&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;Codebook(s)&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;Data&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Below, we will step through each of these separately, setting ourselves up to (hopefully) flawlessly communicate with &lt;code&gt;R&lt;/code&gt; and our data.&lt;/p&gt;
&lt;div id=&#34;packages&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Packages&lt;/h2&gt;
&lt;p&gt;Packages seems like the most basic step, but it is actually very important. &lt;strong&gt;ALWAYS LOAD YOUR PACKAGES IN A VERY INTENTIONAL ORDER AT THE BEGINNING OF YOUR SCRIPT.&lt;/strong&gt; Package conflicts suck, so it needs to be shouted. (Note: Josh will often reload or not follow this advice for didactic reasons, choosing to put library calls above the code. )&lt;/p&gt;
&lt;p&gt;For this tutorial, we are going to quite simple. We will load the &lt;code&gt;psych&lt;/code&gt; package for data descriptives, some options for cleaning and reverse coding, and some evaluations of our scales. The &lt;code&gt;plyr&lt;/code&gt; package is the predecessor of the &lt;code&gt;dplyr&lt;/code&gt; package, which is a core package of the &lt;code&gt;tidyverse&lt;/code&gt;, which you will become quite familiar with in these tutorials. I like the plyr package because it contains a couple of functions (e.g. &lt;code&gt;mapvalues()&lt;/code&gt;) that I find quite useful. Finally, we load the &lt;code&gt;tidyverse&lt;/code&gt; package, which is actually a complilation of 8 packages. Some of these we will use today and some we will use in later tutorials. All are very useful and are arguably some of the most powerful tools R offers.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# load packages
library(psych)
library(plyr)
library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1.9000 ──&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ✔ ggplot2 3.2.1           ✔ purrr   0.3.2      
## ✔ tibble  2.1.3           ✔ dplyr   0.8.3      
## ✔ tidyr   0.8.99.9000     ✔ stringr 1.4.0      
## ✔ readr   1.3.1           ✔ forcats 0.4.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Conflicts ─────────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ ggplot2::%+%()     masks psych::%+%()
## ✖ ggplot2::alpha()   masks psych::alpha()
## ✖ dplyr::arrange()   masks plyr::arrange()
## ✖ purrr::compact()   masks plyr::compact()
## ✖ dplyr::count()     masks plyr::count()
## ✖ dplyr::failwith()  masks plyr::failwith()
## ✖ dplyr::filter()    masks stats::filter()
## ✖ dplyr::id()        masks plyr::id()
## ✖ dplyr::lag()       masks stats::lag()
## ✖ dplyr::mutate()    masks plyr::mutate()
## ✖ dplyr::rename()    masks plyr::rename()
## ✖ dplyr::summarise() masks plyr::summarise()
## ✖ dplyr::summarize() masks plyr::summarize()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;codebook&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Codebook&lt;/h2&gt;
&lt;p&gt;The second step is a codebook. Arguably, this is the first step because you should &lt;em&gt;create&lt;/em&gt; the codebook long before you open &lt;code&gt;R&lt;/code&gt; and load your data.&lt;/p&gt;
&lt;p&gt;In this case, we are going to using some data from the &lt;a href=&#34;https://www.diw.de/en/soep/&#34;&gt;German Socioeconomic Panel Study (GSOEP)&lt;/a&gt;, which is an ongoing Panel Study in Germany. Note that these data are for teaching purposes only, shared under the license for the Comprehensive SOEP teaching dataset, which I, as a contracted SOEP user, can use for teaching purposes. These data represent select cases from the full data set and should not be used for the purpose of publication. The full data are available for free at &lt;a href=&#34;https://www.diw.de/en/diw_02.c.222829.en/access_and_ordering.html&#34; class=&#34;uri&#34;&gt;https://www.diw.de/en/diw_02.c.222829.en/access_and_ordering.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For this tutorial, I created the codebook for you, and included what I believe are the core columns you may need. Some of these columns will not be particularly helpful for this dataset. For example, many of you likely work with datasets that have only a single file while others work with datasetsspread across many files. As a result, the “dataset” column of the codebook may only have a single value whereas for others it may have multiple. With longitudinal data it is likely you will have multiple.&lt;/p&gt;
&lt;p&gt;Here are my core columns that are based on the original data:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;dataset&lt;/strong&gt;: this column indexes the &lt;strong&gt;name&lt;/strong&gt; of the dataset that you will be pulling the data from. This is important because we will use this info later on (see &lt;code&gt;purrr&lt;/code&gt; tutorial) to load and clean specific data files. Even if you don’t have multiple data sets, I believe consistency is more important and suggest using this.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;old_name&lt;/strong&gt;: this column is the name of the variable in the data you are pulling it from. This should be exact. The goal of this column is that it will allow us to &lt;code&gt;select()&lt;/code&gt; variables from the original data file and rename them something that is more useful to us. If you have worked with qualtrics (really any data) you know why this is important.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;item_text&lt;/strong&gt;: this column is the original text that participants saw or a description of the item.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;scale&lt;/strong&gt;: this column tells you what the scale of the variable is. Is it a numeric variable, a text variable, etc. This is helpful for knowing the plausible range.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;reverse&lt;/strong&gt;: this column tells you whether items in a scale need to be reverse coded. I recommend coding this as 1 (leave alone) and -1 (reverse) for reasons that will become clear later.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;mini&lt;/strong&gt;: this column represents the minimum value of scales that are numeric. Leave blank otherwise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;maxi&lt;/strong&gt;: this column represents the maximumv alue of scales that are numeric. Leave blank otherwise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;recode&lt;/strong&gt;: sometimes, we want to recode variables for analyses (e.g. for categorical variables with many levels where sample sizes for some levels are too small to actually do anything with it). I use this column to note the kind of recoding I’ll do to a variable for transparency.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here are additional columns that will make our lives easier or are applicable to some but not all data sets:&lt;/p&gt;
&lt;ol start=&#34;9&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;category&lt;/strong&gt;: broad categories that different variables can be put into. I’m a fan of naming them things like “outcome”, “predictor”, “moderator”, “demographic”, “procedural”, etc. but sometimes use more descriptive labels like “Big 5” to indicate the model from which the measures are derived.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;label&lt;/strong&gt;: label is basically one level lower than category. So if the category is Big 5, the label would be, or example, “A” for Agreeableness, “SWB” for subjective well-being, etc. This column is most important and useful when you have multiple items in a scales, so I’ll typically leave this blank when something is a standalone variable (e.g. sex, single-item scales, etc.).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;item_name&lt;/strong&gt;: This is the lowest level and most descriptive variable. It indicates which item in scale something is. So it may be “kind” for Agreebleness or “sex” for the demographic biological sex variable.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;year&lt;/strong&gt;: for longitudinal data, we have several waves of data and the name of the same item across waves is often different, so it’s important to note to which wave an item belongs. You can do this by noting the wave (e.g. 1, 2, 3), but I prefer the actual year the data were collected (e.g. 2005, 2009, etc.) if that is appropriate. See Lecture #1 on discussion of meaningful time metrics. Note that this differs from that discussion in codebook describes how you collected the data, not necessarily how you want to analyze the data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;new_name&lt;/strong&gt;: This is a column that brings together much of the information we’ve already collected. It’s purpose is to be the new name that we will give to the variable that is more useful and descriptive to us. This is a constructed variable that brings together others. I like to make it a combination of “category”, “label”, “item_name”, and year using varying combos of &#34;_&#34; and “.” that we can use later with tidyverse functions. I typically construct this variable in Excel using the &lt;code&gt;CONCATENATE()&lt;/code&gt; function, but it could also be done in &lt;code&gt;R&lt;/code&gt;. The reason I do it in Excel is that it makes it easier for someone who may be reviewing my codebook.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There is a seperate discussion to be had on naming conventions for your variables, but the important idea to remember is that names convey important information and we want to use this information later on to make our life easier. By coding these variables using this information AND systematically using different seperators we can accomplish this goal.&lt;/p&gt;
&lt;ol start=&#34;14&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;strong&gt;meta&lt;/strong&gt;: Some datasets have a meta name, which essentially means a name that variable has across all waves to make it clear which variables are the same. They are not always useful as some data sets have meta names but no great way of extracting variables using them. But they’re still typically useful to include in your codebook regardless.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Below, I’ll load in the codebook we will use for this study, which will include all of the above columns.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# set the path
wd &amp;lt;- &amp;quot;https://github.com/emoriebeck/R-tutorials/blob/master/ALDA/week_1_descriptives&amp;quot;

# load the codebook
(codebook &amp;lt;- url(sprintf(&amp;quot;%s/codebook.csv?raw=true&amp;quot;, wd)) %&amp;gt;% 
    read_csv(.) %&amp;gt;%
    mutate(old_name = str_to_lower(old_name)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Parsed with column specification:
## cols(
##   dataset = col_character(),
##   old_name = col_character(),
##   item_text = col_character(),
##   scale = col_character(),
##   category = col_character(),
##   label = col_character(),
##   item_name = col_character(),
##   year = col_double(),
##   new_name = col_character(),
##   reverse = col_double(),
##   mini = col_double(),
##   maxi = col_double(),
##   recode = col_character()
## )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 153 x 13
##    dataset old_name item_text scale category label item_name  year new_name
##    &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   
##  1 &amp;lt;NA&amp;gt;    persnr   Never Ch… &amp;lt;NA&amp;gt;  Procedu… &amp;lt;NA&amp;gt;  SID           0 Procedu…
##  2 &amp;lt;NA&amp;gt;    hhnr     househol… &amp;lt;NA&amp;gt;  Procedu… &amp;lt;NA&amp;gt;  household     0 Procedu…
##  3 ppfad   gebjahr  Year of … nume… Demogra… &amp;lt;NA&amp;gt;  DOB           0 Demogra…
##  4 ppfad   sex      Sex       &amp;quot;\n1… Demogra… &amp;lt;NA&amp;gt;  Sex           0 Demogra…
##  5 vp      vp12501  Thorough… &amp;lt;NA&amp;gt;  Big 5    C     thorough   2005 Big 5__…
##  6 zp      zp12001  Thorough… &amp;lt;NA&amp;gt;  Big 5    C     thorough   2009 Big 5__…
##  7 bdp     bdp15101 Thorough… &amp;lt;NA&amp;gt;  Big 5    C     thorough   2013 Big 5__…
##  8 vp      vp12502  Am commu… &amp;lt;NA&amp;gt;  Big 5    E     communic   2005 Big 5__…
##  9 zp      zp12002  Am commu… &amp;lt;NA&amp;gt;  Big 5    E     communic   2009 Big 5__…
## 10 bdp     bdp15102 Am commu… &amp;lt;NA&amp;gt;  Big 5    E     communic   2013 Big 5__…
## # … with 143 more rows, and 4 more variables: reverse &amp;lt;dbl&amp;gt;, mini &amp;lt;dbl&amp;gt;,
## #   maxi &amp;lt;dbl&amp;gt;, recode &amp;lt;chr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data&lt;/h2&gt;
&lt;p&gt;First, we need to load in the data. We’re going to use three waves of data from the German Socioeconomic Panel Study, which is a longitudinal study of German households that has been conducted since 1984. We’re going to use more recent data from three waves of personality data collected between 2005 and 2013.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: we will be using the teaching set of the GSOEP data set. I will not be pulling from the raw files as a result of this. I will also not be mirroring the format that you would usually load the GSOEP from because that is slightly more complicated and somethng we will return to in a later tutorial after we have more skills. I’ve left that code for now, but it won’t make a lot of sense right now.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;path &amp;lt;- &amp;quot;~/Box/network/other projects/PCLE Replication/data/sav_files&amp;quot;
ref &amp;lt;- sprintf(&amp;quot;%s/cirdef.sav&amp;quot;, path) %&amp;gt;% haven::read_sav(.) %&amp;gt;% select(hhnr, rgroup20)
read_fun &amp;lt;- function(Year){
  vars &amp;lt;- (codebook %&amp;gt;% filter(year == Year | year == 0))$old_name
  set &amp;lt;- (codebook %&amp;gt;% filter(year == Year))$dataset[1]
  sprintf(&amp;quot;%s/%s.sav&amp;quot;, path, set) %&amp;gt;% haven::read_sav(.) %&amp;gt;%
    full_join(ref) %&amp;gt;%
    filter(rgroup20 &amp;gt; 10) %&amp;gt;%
    select(one_of(vars)) %&amp;gt;%
    gather(key = item, value = value, -persnr, -hhnr, na.rm = T)
}

vars &amp;lt;- (codebook %&amp;gt;% filter(year == 0))$old_name
dem &amp;lt;- sprintf(&amp;quot;%s/ppfad.sav&amp;quot;, path) %&amp;gt;% 
  haven::read_sav(.) %&amp;gt;%
  select(vars)
  
tibble(year = c(2005:2015)) %&amp;gt;%
  mutate(data = map(year, read_fun)) %&amp;gt;%
  select(-year) %&amp;gt;% 
  unnest(data) %&amp;gt;%
  distinct() %&amp;gt;% 
  filter(!is.na(value)) %&amp;gt;%
  spread(key = item, value = value) %&amp;gt;%
  left_join(dem) %&amp;gt;%
  write.csv(., file = &amp;quot;~/Documents/Github/R-tutorials/ALDA/week_1_descriptives/data/wdeek_1_data.csv&amp;quot;, row.names = F)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code below shows how I would read in and rename a wide-format data set using the codebook I created.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;old.names &amp;lt;- codebook$old_name # get old column names
new.names &amp;lt;- codebook$new_name # get new column names

(soep &amp;lt;- url(sprintf(&amp;quot;%s/data/week_1_data.csv?raw=true&amp;quot;, wd)) %&amp;gt;% # path to data
  read_csv(.) %&amp;gt;% # read in data
  select(old.names) %&amp;gt;% # select the columns from our codebook
  setNames(new.names)) # rename columns with our new names&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Parsed with column specification:
## cols(
##   .default = col_double()
## )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## See spec(...) for full column specifications.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 28,290 x 153
##    Procedural__SID Procedural__hou… Demographic__DOB Demographic__Sex
##              &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;
##  1             901               94             1951                2
##  2            1202              124             1913                2
##  3            2301              230             1946                1
##  4            2302              230             1946                2
##  5            2304              230             1978                1
##  6            2305              230             1946                2
##  7            4601              469             1933                2
##  8            4701              477             1919                2
##  9            4901              493             1925                2
## 10            5201              523             1955                1
## # … with 28,280 more rows, and 149 more variables: `Big
## #   5__C_thorough.2005` &amp;lt;dbl&amp;gt;, `Big 5__C_thorough.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_thorough.2013` &amp;lt;dbl&amp;gt;, `Big 5__E_communic.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__E_communic.2009` &amp;lt;dbl&amp;gt;, `Big 5__E_communic.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_coarse.2005` &amp;lt;dbl&amp;gt;, `Big 5__A_coarse.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_coarse.2013` &amp;lt;dbl&amp;gt;, `Big 5__O_original.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_original.2009` &amp;lt;dbl&amp;gt;, `Big 5__O_original.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_worry.2005` &amp;lt;dbl&amp;gt;, `Big 5__N_worry.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_worry.2013` &amp;lt;dbl&amp;gt;, `Big 5__A_forgive.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_forgive.2009` &amp;lt;dbl&amp;gt;, `Big 5__A_forgive.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_lazy.2005` &amp;lt;dbl&amp;gt;, `Big 5__C_lazy.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_lazy.2013` &amp;lt;dbl&amp;gt;, `Big 5__E_sociable.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__E_sociable.2009` &amp;lt;dbl&amp;gt;, `Big 5__E_sociable.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_artistic.2005` &amp;lt;dbl&amp;gt;, `Big 5__O_artistic.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_artistic.2013` &amp;lt;dbl&amp;gt;, `Big 5__N_nervous.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_nervous.2009` &amp;lt;dbl&amp;gt;, `Big 5__N_nervous.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_efficient.2005` &amp;lt;dbl&amp;gt;, `Big 5__C_efficient.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_efficient.2013` &amp;lt;dbl&amp;gt;, `Big 5__E_reserved.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__E_reserved.2009` &amp;lt;dbl&amp;gt;, `Big 5__E_reserved.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_friendly.2005` &amp;lt;dbl&amp;gt;, `Big 5__A_friendly.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_friendly.2013` &amp;lt;dbl&amp;gt;, `Big 5__O_imagin.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_imagin.2009` &amp;lt;dbl&amp;gt;, `Big 5__O_imagin.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_dealStress.2005` &amp;lt;dbl&amp;gt;, `Big 5__N_dealStress.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_dealStress.2013` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2005` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2006` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2007` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2008` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2009` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2010` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2011` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2012` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2013` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2014` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2015` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2005` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2006` &amp;lt;dbl&amp;gt;,
## #   `Life Event__ChldMvOut.2007` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2008` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2009` &amp;lt;dbl&amp;gt;,
## #   `Life Event__ChldMvOut.2010` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2011` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2012` &amp;lt;dbl&amp;gt;,
## #   `Life Event__ChldMvOut.2013` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2014` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2015` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2005` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2006` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2007` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2008` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2009` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2010` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2011` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2012` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2013` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2014` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2015` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2005` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2006` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2007` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2008` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2009` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2010` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2011` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2012` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2013` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2014` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2015` &amp;lt;dbl&amp;gt;,
## #   `Life Event__NewPart.2011` &amp;lt;dbl&amp;gt;, `Life Event__NewPart.2012` &amp;lt;dbl&amp;gt;,
## #   `Life Event__NewPart.2013` &amp;lt;dbl&amp;gt;, `Life Event__NewPart.2014` &amp;lt;dbl&amp;gt;,
## #   `Life Event__NewPart.2015` &amp;lt;dbl&amp;gt;, `Life Event__Married.2005` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Married.2006` &amp;lt;dbl&amp;gt;, `Life Event__Married.2007` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Married.2008` &amp;lt;dbl&amp;gt;, `Life Event__Married.2009` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Married.2010` &amp;lt;dbl&amp;gt;, …&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;clean-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Clean Data&lt;/h1&gt;
&lt;div id=&#34;recode-variables&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Recode Variables&lt;/h2&gt;
&lt;p&gt;Many of the data we work with have observations that are missing for a variety of reasons. In &lt;code&gt;R&lt;/code&gt;, we treat missing values as &lt;code&gt;NA&lt;/code&gt;, but many other programs from which you may be importing your data may use other codes (e.g. 999, -999, etc.). Large panel studies tend to use small negative values to indicate different types of missingness. This is why it is important to note down the scale in your codebook. That way you can check which values may need to be recoded to explicit &lt;code&gt;NA&lt;/code&gt; values.&lt;/p&gt;
&lt;p&gt;In the GSOEP, &lt;code&gt;-1&lt;/code&gt; to &lt;code&gt;-7&lt;/code&gt; indicate various types of missing values, so we will recode these to &lt;code&gt;NA&lt;/code&gt;. To do this, we will use one of my favorite functions, &lt;code&gt;mapvalues()&lt;/code&gt;, from the &lt;code&gt;plyr&lt;/code&gt; package. In later tutorials where we read in and manipulate more complex data sets, we will use &lt;code&gt;mapvalues()&lt;/code&gt; a lot. Basically, mapvalues takes 4 key arguments: (1) the variable you are recoding, (2) a vector of initial values &lt;code&gt;from&lt;/code&gt; which you want to (3) recode your variable &lt;code&gt;to&lt;/code&gt; using a vector of new values in the same order as the old values, and (4) a way to turn off warnings if some levels are not in your data (&lt;code&gt;warn_missing = F&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(soep &amp;lt;- soep %&amp;gt;%
  mutate_all(~as.numeric(mapvalues(., from = seq(-1,-7, -1), # recode negative 
                to = rep(NA, 7), warn_missing = F)))) # values to NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 28,290 x 153
##    Procedural__SID Procedural__hou… Demographic__DOB Demographic__Sex
##              &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;
##  1             901               94             1951                2
##  2            1202              124             1913                2
##  3            2301              230             1946                1
##  4            2302              230             1946                2
##  5            2304              230             1978                1
##  6            2305              230             1946                2
##  7            4601              469             1933                2
##  8            4701              477             1919                2
##  9            4901              493             1925                2
## 10            5201              523             1955                1
## # … with 28,280 more rows, and 149 more variables: `Big
## #   5__C_thorough.2005` &amp;lt;dbl&amp;gt;, `Big 5__C_thorough.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_thorough.2013` &amp;lt;dbl&amp;gt;, `Big 5__E_communic.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__E_communic.2009` &amp;lt;dbl&amp;gt;, `Big 5__E_communic.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_coarse.2005` &amp;lt;dbl&amp;gt;, `Big 5__A_coarse.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_coarse.2013` &amp;lt;dbl&amp;gt;, `Big 5__O_original.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_original.2009` &amp;lt;dbl&amp;gt;, `Big 5__O_original.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_worry.2005` &amp;lt;dbl&amp;gt;, `Big 5__N_worry.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_worry.2013` &amp;lt;dbl&amp;gt;, `Big 5__A_forgive.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_forgive.2009` &amp;lt;dbl&amp;gt;, `Big 5__A_forgive.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_lazy.2005` &amp;lt;dbl&amp;gt;, `Big 5__C_lazy.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_lazy.2013` &amp;lt;dbl&amp;gt;, `Big 5__E_sociable.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__E_sociable.2009` &amp;lt;dbl&amp;gt;, `Big 5__E_sociable.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_artistic.2005` &amp;lt;dbl&amp;gt;, `Big 5__O_artistic.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_artistic.2013` &amp;lt;dbl&amp;gt;, `Big 5__N_nervous.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_nervous.2009` &amp;lt;dbl&amp;gt;, `Big 5__N_nervous.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_efficient.2005` &amp;lt;dbl&amp;gt;, `Big 5__C_efficient.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__C_efficient.2013` &amp;lt;dbl&amp;gt;, `Big 5__E_reserved.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__E_reserved.2009` &amp;lt;dbl&amp;gt;, `Big 5__E_reserved.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_friendly.2005` &amp;lt;dbl&amp;gt;, `Big 5__A_friendly.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__A_friendly.2013` &amp;lt;dbl&amp;gt;, `Big 5__O_imagin.2005` &amp;lt;dbl&amp;gt;, `Big
## #   5__O_imagin.2009` &amp;lt;dbl&amp;gt;, `Big 5__O_imagin.2013` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_dealStress.2005` &amp;lt;dbl&amp;gt;, `Big 5__N_dealStress.2009` &amp;lt;dbl&amp;gt;, `Big
## #   5__N_dealStress.2013` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2005` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2006` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2007` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2008` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2009` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2010` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2011` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2012` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2013` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldBrth.2014` &amp;lt;dbl&amp;gt;, `Life Event__ChldBrth.2015` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2005` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2006` &amp;lt;dbl&amp;gt;,
## #   `Life Event__ChldMvOut.2007` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2008` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2009` &amp;lt;dbl&amp;gt;,
## #   `Life Event__ChldMvOut.2010` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2011` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2012` &amp;lt;dbl&amp;gt;,
## #   `Life Event__ChldMvOut.2013` &amp;lt;dbl&amp;gt;, `Life
## #   Event__ChldMvOut.2014` &amp;lt;dbl&amp;gt;, `Life Event__ChldMvOut.2015` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2005` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2006` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2007` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2008` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2009` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2010` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2011` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2012` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2013` &amp;lt;dbl&amp;gt;, `Life Event__Divorce.2014` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Divorce.2015` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2005` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2006` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2007` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2008` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2009` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2010` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2011` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2012` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2013` &amp;lt;dbl&amp;gt;,
## #   `Life Event__DadDied.2014` &amp;lt;dbl&amp;gt;, `Life Event__DadDied.2015` &amp;lt;dbl&amp;gt;,
## #   `Life Event__NewPart.2011` &amp;lt;dbl&amp;gt;, `Life Event__NewPart.2012` &amp;lt;dbl&amp;gt;,
## #   `Life Event__NewPart.2013` &amp;lt;dbl&amp;gt;, `Life Event__NewPart.2014` &amp;lt;dbl&amp;gt;,
## #   `Life Event__NewPart.2015` &amp;lt;dbl&amp;gt;, `Life Event__Married.2005` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Married.2006` &amp;lt;dbl&amp;gt;, `Life Event__Married.2007` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Married.2008` &amp;lt;dbl&amp;gt;, `Life Event__Married.2009` &amp;lt;dbl&amp;gt;,
## #   `Life Event__Married.2010` &amp;lt;dbl&amp;gt;, …&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;reverse-scoring&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Reverse-Scoring&lt;/h2&gt;
&lt;p&gt;Many scales we use have items that are positively or negatively keyed. High ratings on positively keyed items are indicative of being high on a construct. In contrast, high ratings on negatively keyed items are indicative of being low on a construct. Thus, to create the composite scores of constructs we often use, we must first “reverse” the negatively keyed items so that high scores indicate being higher on the construct.&lt;/p&gt;
&lt;p&gt;There are a few ways to do this in &lt;code&gt;R&lt;/code&gt;. Below, I’ll demonstrate how to do so using the &lt;code&gt;reverse.code()&lt;/code&gt; function in the &lt;code&gt;psych&lt;/code&gt; package in &lt;code&gt;R&lt;/code&gt;. This function was built to make reverse coding more efficient (i.e. please don’t run every item that needs to be recoded with separate lines of code!!).&lt;/p&gt;
&lt;p&gt;Before we can do that, though, we need to restructure the data a bit in order to bring in the reverse coding information from our codebook. We will talk more about what’s happening here in later tutorials on &lt;code&gt;tidyr&lt;/code&gt;, so for now, just bear with me.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(soep_long &amp;lt;- soep %&amp;gt;%
  gather(key = item, value = value, -contains(&amp;quot;Procedural&amp;quot;), # change to long format
         -contains(&amp;quot;Demographic&amp;quot;), na.rm = T) %&amp;gt;%
  left_join(codebook %&amp;gt;% select(item = new_name, reverse, mini, maxi)) %&amp;gt;% # bring in codebook
  separate(item, c(&amp;quot;type&amp;quot;, &amp;quot;item&amp;quot;), sep = &amp;quot;__&amp;quot;) %&amp;gt;% # separate category
  separate(item, c(&amp;quot;item&amp;quot;, &amp;quot;year&amp;quot;), sep = &amp;quot;[.]&amp;quot;) %&amp;gt;% # seprate year
  separate(item, c(&amp;quot;item&amp;quot;, &amp;quot;scrap&amp;quot;), sep = &amp;quot;_&amp;quot;) %&amp;gt;% # separate scale and item
  mutate(value = as.numeric(value), # change to numeric
         value = ifelse(reverse == -1, 
            reverse.code(-1, value, mini = mini, maxi = maxi), value)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Joining, by = &amp;quot;item&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 19618 rows
## [452105, 452106, 452107, 452108, 452109, 452110, 452111, 452112, 452113,
## 452114, 452115, 452116, 452117, 452118, 452119, 452120, 452121, 452122,
## 452123, 452124, ...].&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 471,722 x 12
##    Procedural__SID Procedural__hou… Demographic__DOB Demographic__Sex type 
##              &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;
##  1             901               94             1951                2 Big 5
##  2            1202              124             1913                2 Big 5
##  3            2301              230             1946                1 Big 5
##  4            2302              230             1946                2 Big 5
##  5            2304              230             1978                1 Big 5
##  6            4601              469             1933                2 Big 5
##  7            4701              477             1919                2 Big 5
##  8            4901              493             1925                2 Big 5
##  9            5201              523             1955                1 Big 5
## 10            5202              523             1956                2 Big 5
## # … with 471,712 more rows, and 7 more variables: item &amp;lt;chr&amp;gt;, scrap &amp;lt;chr&amp;gt;,
## #   year &amp;lt;chr&amp;gt;, value &amp;lt;dbl&amp;gt;, reverse &amp;lt;dbl&amp;gt;, mini &amp;lt;dbl&amp;gt;, maxi &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;create-composites&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Create Composites&lt;/h2&gt;
&lt;p&gt;Now that we have reverse coded our items, we can create composites.&lt;/p&gt;
&lt;div id=&#34;bfi-s&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;BFI-S&lt;/h3&gt;
&lt;p&gt;We’ll start with our scale – in this case, the Big 5 from the German translation of the BFI-S.&lt;/p&gt;
&lt;p&gt;Here’s the simplest way, which is also the long way because you’d have to do it for each scale in each year, which I don’t recommend.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;soep$C.2005 &amp;lt;- with(soep, rowMeans(cbind(`Big 5__C_thorough.2005`, `Big 5__C_lazy.2005`, `Big 5__C_efficient.2005`), na.rm = T)) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But personally, I don’t have a desire to do that 15 times (5 traits times 3 waves), so we can use our codebook and &lt;code&gt;dplyr&lt;/code&gt; to make our lives a whole lot easier. In general, trying to run everything simultanously saves from copy-paste errors, makes your code more readable, and reduces the total amount of code. So while the below code may not make intuiative sense immediately, it is nonetheless what we are working towards.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;soep &amp;lt;- soep %&amp;gt;% select(-C.2005) # get rid of added column

(b5_soep_long &amp;lt;- soep_long %&amp;gt;%
  filter(type == &amp;quot;Big 5&amp;quot;) %&amp;gt;% # keep Big 5 variables
  group_by(Procedural__SID, item, year) %&amp;gt;% # group by person, construct, &amp;amp; year
  summarize(value = mean(value, na.rm = T)) %&amp;gt;% # calculate means
  ungroup() %&amp;gt;% # ungroup
  left_join(soep_long %&amp;gt;% # bring demographic info back in 
    select(Procedural__SID, DOB = Demographic__DOB, Sex = Demographic__Sex) %&amp;gt;%
    distinct()))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Joining, by = &amp;quot;Procedural__SID&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 151,186 x 6
##    Procedural__SID item  year  value   DOB   Sex
##              &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1             901 A     2005   5     1951     2
##  2             901 A     2009   5.33  1951     2
##  3             901 A     2013   5     1951     2
##  4             901 C     2005   5.33  1951     2
##  5             901 C     2009   5.5   1951     2
##  6             901 C     2013   6     1951     2
##  7             901 E     2005   4     1951     2
##  8             901 E     2009   4     1951     2
##  9             901 E     2013   4     1951     2
## 10             901 N     2005   4     1951     2
## # … with 151,176 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;life-events&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Life Events&lt;/h3&gt;
&lt;p&gt;We also want to create a variable that indexes whether our participants experienced any of the life events during the years of interest (2005-2015).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(events_long &amp;lt;- soep_long %&amp;gt;%
  filter(type == &amp;quot;Life Event&amp;quot;) %&amp;gt;% # keep only life events
  group_by(Procedural__SID, item) %&amp;gt;% # group by person and event
  summarize(value = sum(value, na.rm = T), # sum up whether they experiened the event at all
            value = ifelse(value &amp;gt; 1, 1, 0))) # if more than once 1, otherwise 0&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 15,061 x 3
## # Groups:   Procedural__SID [10,019]
##    Procedural__SID item      value
##              &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;
##  1             901 MomDied       1
##  2            2301 MoveIn        0
##  3            2301 PartDied      1
##  4            2305 MoveIn        0
##  5            4601 PartDied      0
##  6            5201 ChldMvOut     1
##  7            5201 DadDied       0
##  8            5202 ChldMvOut     1
##  9            5203 MoveIn        1
## 10            5303 MomDied       0
## # … with 15,051 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;descriptives&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Descriptives&lt;/h1&gt;
&lt;p&gt;Descriptives of your data are incredibly important. They are your first line of defense against things that could go wrong later on when you run inferential stats. They help you check the distribution of your variables (e.g. non-normally distributed), look for implausible values made through coding or participant error, and allow you to anticipate what your findings will look like.&lt;/p&gt;
&lt;p&gt;There are lots of ways to create great tables of descriptives. My favorite way is using &lt;code&gt;dplyr&lt;/code&gt;, but we will save that for a later lesson on creating great APA style tables in &lt;code&gt;R&lt;/code&gt;. For now, we’ll use a wonderfully helpful function from the &lt;code&gt;psych&lt;/code&gt; package called &lt;code&gt;describe()&lt;/code&gt; in conjunction with a small amount of &lt;code&gt;tidyr&lt;/code&gt; to reshape the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b5_soep_long  %&amp;gt;%
  unite(tmp, item, year, sep = &amp;quot;_&amp;quot;) %&amp;gt;% # make new column that joins item and year
  spread(tmp, value) %&amp;gt;% # make wide because that helps describe
  describe(.) # call describe&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                 vars     n       mean          sd     median    trimmed
## Procedural__SID    1 16719 8321022.91 10677731.19 3105002.00 6487615.30
## DOB                2 16719    1960.03       18.48    1960.00    1960.22
## Sex                3 16719       1.52        0.50       2.00       1.53
## A_2005             4 10419       5.79        0.98       6.00       5.83
## A_2009             5 10294       5.68        0.99       5.67       5.72
## A_2013             6  9535       5.74        0.96       5.67       5.78
## C_2005             7 10412       6.23        0.96       6.33       6.34
## C_2009             8 10290       6.16        0.95       6.33       6.25
## C_2013             9  9530       6.17        0.91       6.33       6.25
## E_2005            10 10416       5.15        1.15       5.33       5.18
## E_2009            11 10291       5.11        1.15       5.00       5.13
## E_2013            12  9533       5.20        1.11       5.33       5.24
## N_2005            13 10413       4.71        1.23       4.67       4.72
## N_2009            14 10294       4.84        1.22       5.00       4.87
## N_2013            15  9534       4.92        1.21       5.00       4.93
## O_2005            16 10408       4.51        1.22       4.67       4.53
## O_2009            17 10287       4.40        1.22       4.33       4.41
## O_2013            18  9530       4.60        1.18       4.67       4.62
##                        mad     min        max       range  skew kurtosis
## Procedural__SID 3735541.17  901.00 3.5022e+07 35021101.00  1.50     0.56
## DOB                  20.76 1909.00 1.9950e+03       86.00 -0.08    -0.84
## Sex                   0.00    1.00 2.0000e+00        1.00 -0.10    -1.99
## A_2005                0.99    1.00 7.5000e+00        6.50 -0.40    -0.14
## A_2009                0.99    1.33 8.0000e+00        6.67 -0.36    -0.19
## A_2013                0.99    1.33 8.0000e+00        6.67 -0.43     0.05
## C_2005                0.99    1.00 8.0000e+00        7.00 -0.95     0.84
## C_2009                0.99    1.00 8.0000e+00        7.00 -0.82     0.49
## C_2013                0.99    1.33 8.0000e+00        6.67 -0.72     0.17
## E_2005                0.99    1.00 7.5000e+00        6.50 -0.27    -0.16
## E_2009                0.99    1.00 7.3300e+00        6.33 -0.23    -0.18
## E_2013                0.99    1.33 7.3300e+00        6.00 -0.29    -0.18
## N_2005                1.48    1.50 8.0000e+00        6.50 -0.07    -0.32
## N_2009                0.99    1.50 7.6700e+00        6.17 -0.17    -0.30
## N_2013                1.48    1.50 8.0000e+00        6.50 -0.15    -0.30
## O_2005                1.48    1.00 7.0000e+00        6.00 -0.23    -0.18
## O_2009                1.48    1.00 7.0000e+00        6.00 -0.10    -0.30
## O_2013                0.99    1.00 7.0000e+00        6.00 -0.21    -0.20
##                       se
## Procedural__SID 82579.80
## DOB                 0.14
## Sex                 0.00
## A_2005              0.01
## A_2009              0.01
## A_2013              0.01
## C_2005              0.01
## C_2009              0.01
## C_2013              0.01
## E_2005              0.01
## E_2009              0.01
## E_2013              0.01
## N_2005              0.01
## N_2009              0.01
## N_2013              0.01
## O_2005              0.01
## O_2009              0.01
## O_2013              0.01&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For count variables, like life events, we need to use something slightly different. We’re typically more interested in counts – in this case, how many people experienced each life event in the 10 years we’re considering?&lt;/p&gt;
&lt;p&gt;To do this, we’ll use a little bit of &lt;code&gt;dplyr&lt;/code&gt; rather than the base &lt;code&gt;R&lt;/code&gt; function &lt;code&gt;table()&lt;/code&gt; that is often used for count data. Instead, we’ll use a combination of &lt;code&gt;group_by()&lt;/code&gt; and &lt;code&gt;n()&lt;/code&gt; to get the counts by group. In the end, we’re left with a nice little table of counts.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;events_long %&amp;gt;%
  group_by(item, value) %&amp;gt;% 
  summarize(N = n()) %&amp;gt;%
  ungroup() %&amp;gt;%
  spread(value, N)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 x 3
##    item        `0`   `1`
##    &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
##  1 ChldBrth   1600   735
##  2 ChldMvOut  1555   830
##  3 DadDied     953   213
##  4 Divorce     414   122
##  5 Married    1646   331
##  6 MomDied     929   219
##  7 MoveIn     1403   419
##  8 NewPart    1207   420
##  9 PartDied    402    76
## 10 SepPart    1172   415&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;scale-reliability&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Scale Reliability&lt;/h2&gt;
&lt;p&gt;When we work with scales, it’s often a good idea to check the internal consistency of your scale. If the scale isn’t performing how it should be, that could critically impact the inferences you make from your data.&lt;/p&gt;
&lt;p&gt;To check the internal consistency of our Big 5 scales, we will use the &lt;code&gt;alpha()&lt;/code&gt; function from the &lt;code&gt;psych&lt;/code&gt; package, which will give us Cronbach’s as well as a number of other indicators of internal consistency.&lt;/p&gt;
&lt;p&gt;Here’s the way you may have seen / done this in the past.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;alpha.C.2005 &amp;lt;- with(soep, psych::alpha(x = cbind(`Big 5__C_thorough.2005`, 
                                  `Big 5__C_lazy.2005`, `Big 5__C_efficient.2005`)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in psych::alpha(x = cbind(`Big 5__C_thorough.2005`, `Big 5__C_lazy.2005`, : Some items were negatively correlated with the total scale and probably 
## should be reversed.  
## To do this, run the function again with the &amp;#39;check.keys=TRUE&amp;#39; option&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Some items ( Big 5__C_lazy.2005 ) were negatively correlated with the total scale and 
## probably should be reversed.  
## To do this, run the function again with the &amp;#39;check.keys=TRUE&amp;#39; option&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But again, doing this 15 times would be quite a pain and would open you up to the possibility of a lot of copy and paste errors.&lt;/p&gt;
&lt;p&gt;So instead, to do this, I’m going to use a mix of the tidyverse. At first glance, it may seem complex but as you move through other tutorials (particularly the &lt;code&gt;purrr&lt;/code&gt; tutorial), it will begin to make much more sense.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# short function to reshape data and run alpha
alpha_fun &amp;lt;- function(df){
  df %&amp;gt;% spread(scrap,value) %&amp;gt;% psych::alpha(.)
}

(alphas &amp;lt;- soep_long %&amp;gt;%
  filter(type == &amp;quot;Big 5&amp;quot;) %&amp;gt;% # filter out Big 5
  select(Procedural__SID, item:value) %&amp;gt;% # get rid of extra columns
  group_by(item, year) %&amp;gt;% # group by construct and year
  nest() %&amp;gt;% # nest the data
  mutate(alpha_res = map(data, alpha_fun), # run alpha
         alpha = map(alpha_res, ~.$total[2])) %&amp;gt;% # get the alpha value
  unnest(alpha)) # pull it out of the list column&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 15 x 5
## # Groups:   item, year [15]
##    item  year            data alpha_res std.alpha
##    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;list&amp;lt;df[,3]&amp;gt;&amp;gt; &amp;lt;list&amp;gt;        &amp;lt;dbl&amp;gt;
##  1 C     2005    [31,117 × 3] &amp;lt;psych&amp;gt;       0.515
##  2 C     2009    [30,728 × 3] &amp;lt;psych&amp;gt;       0.494
##  3 C     2013    [28,496 × 3] &amp;lt;psych&amp;gt;       0.482
##  4 E     2005    [31,188 × 3] &amp;lt;psych&amp;gt;       0.540
##  5 E     2009    [30,770 × 3] &amp;lt;psych&amp;gt;       0.530
##  6 E     2013    [28,532 × 3] &amp;lt;psych&amp;gt;       0.544
##  7 A     2005    [31,184 × 3] &amp;lt;psych&amp;gt;       0.418
##  8 A     2009    [30,796 × 3] &amp;lt;psych&amp;gt;       0.410
##  9 A     2013    [28,529 × 3] &amp;lt;psych&amp;gt;       0.401
## 10 O     2005    [31,091 × 3] &amp;lt;psych&amp;gt;       0.527
## 11 O     2009    [30,722 × 3] &amp;lt;psych&amp;gt;       0.510
## 12 O     2013    [28,451 × 3] &amp;lt;psych&amp;gt;       0.497
## 13 N     2005    [31,162 × 3] &amp;lt;psych&amp;gt;       0.473
## 14 N     2009    [30,802 × 3] &amp;lt;psych&amp;gt;       0.490
## 15 N     2013    [28,536 × 3] &amp;lt;psych&amp;gt;       0.480&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;zero-order-correlations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Zero-Order Correlations&lt;/h2&gt;
&lt;p&gt;Finally, we often want to look at the zero-order correlation among study variables to make sure they are performing as we think they should.&lt;/p&gt;
&lt;p&gt;To run the correlations, we will need to have our data in wide format, so we’re going to do a little bit of reshaping before we do.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b5_soep_long %&amp;gt;%
  unite(tmp, item, year, sep = &amp;quot;_&amp;quot;) %&amp;gt;%
  spread(key = tmp, value = value) %&amp;gt;% 
  select(-Procedural__SID) %&amp;gt;%
  cor(., use = &amp;quot;pairwise&amp;quot;) %&amp;gt;%
  round(., 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          DOB   Sex A_2005 A_2009 A_2013 C_2005 C_2009 C_2013 E_2005 E_2009
## DOB     1.00  0.00  -0.08  -0.07  -0.06  -0.13  -0.12  -0.14   0.10   0.12
## Sex     0.00  1.00   0.18   0.17   0.18   0.05   0.07   0.09   0.08   0.08
## A_2005 -0.08  0.18   1.00   0.50   0.50   0.32   0.20   0.19   0.10   0.06
## A_2009 -0.07  0.17   0.50   1.00   0.55   0.19   0.28   0.18   0.05   0.08
## A_2013 -0.06  0.18   0.50   0.55   1.00   0.18   0.19   0.29   0.04   0.06
## C_2005 -0.13  0.05   0.32   0.19   0.18   1.00   0.52   0.48   0.19   0.10
## C_2009 -0.12  0.07   0.20   0.28   0.19   0.52   1.00   0.55   0.12   0.16
## C_2013 -0.14  0.09   0.19   0.18   0.29   0.48   0.55   1.00   0.13   0.14
## E_2005  0.10  0.08   0.10   0.05   0.04   0.19   0.12   0.13   1.00   0.61
## E_2009  0.12  0.08   0.06   0.08   0.06   0.10   0.16   0.14   0.61   1.00
## E_2013  0.10  0.11   0.04   0.04   0.07   0.10   0.10   0.18   0.59   0.65
## N_2005  0.06 -0.18   0.10   0.06   0.02   0.09   0.06   0.03   0.18   0.10
## N_2009  0.03 -0.22   0.07   0.09   0.03   0.06   0.08   0.05   0.13   0.16
## N_2013  0.02 -0.21   0.06   0.06   0.10   0.04   0.06   0.08   0.10   0.10
## O_2005  0.11  0.06   0.12   0.09   0.07   0.17   0.12   0.08   0.40   0.29
## O_2009  0.10  0.05   0.05   0.11   0.07   0.06   0.13   0.08   0.26   0.36
## O_2013  0.05  0.07   0.08   0.09   0.13   0.07   0.08   0.15   0.24   0.28
##        E_2013 N_2005 N_2009 N_2013 O_2005 O_2009 O_2013
## DOB      0.10   0.06   0.03   0.02   0.11   0.10   0.05
## Sex      0.11  -0.18  -0.22  -0.21   0.06   0.05   0.07
## A_2005   0.04   0.10   0.07   0.06   0.12   0.05   0.08
## A_2009   0.04   0.06   0.09   0.06   0.09   0.11   0.09
## A_2013   0.07   0.02   0.03   0.10   0.07   0.07   0.13
## C_2005   0.10   0.09   0.06   0.04   0.17   0.06   0.07
## C_2009   0.10   0.06   0.08   0.06   0.12   0.13   0.08
## C_2013   0.18   0.03   0.05   0.08   0.08   0.08   0.15
## E_2005   0.59   0.18   0.13   0.10   0.40   0.26   0.24
## E_2009   0.65   0.10   0.16   0.10   0.29   0.36   0.28
## E_2013   1.00   0.11   0.13   0.15   0.26   0.28   0.35
## N_2005   0.11   1.00   0.55   0.53   0.09   0.08   0.06
## N_2009   0.13   0.55   1.00   0.60   0.06   0.07   0.07
## N_2013   0.15   0.53   0.60   1.00   0.05   0.05   0.05
## O_2005   0.26   0.09   0.06   0.05   1.00   0.58   0.55
## O_2009   0.28   0.08   0.07   0.05   0.58   1.00   0.61
## O_2013   0.35   0.06   0.07   0.05   0.55   0.61   1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a lot of values and a little hard to make sense of, so as a bonus, I’m going to give you a little bit of more complex code that makes this more readable (and publishable ).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;r &amp;lt;- b5_soep_long %&amp;gt;%
  unite(tmp, item, year, sep = &amp;quot;_&amp;quot;) %&amp;gt;%
  spread(key = tmp, value = value) %&amp;gt;% 
  select(-Procedural__SID, -DOB, -Sex) %&amp;gt;%
  cor(., use = &amp;quot;pairwise&amp;quot;) 

r[upper.tri(r, diag = T)] &amp;lt;- NA
diag(r) &amp;lt;- (alphas %&amp;gt;% arrange(item, year))$std.alpha

r %&amp;gt;% data.frame %&amp;gt;%
  rownames_to_column(&amp;quot;V1&amp;quot;) %&amp;gt;%
  gather(key = V2, value = r, na.rm = T, -V1) %&amp;gt;%
  separate(V1, c(&amp;quot;T1&amp;quot;, &amp;quot;Year1&amp;quot;), sep = &amp;quot;_&amp;quot;) %&amp;gt;%
  separate(V2, c(&amp;quot;T2&amp;quot;, &amp;quot;Year2&amp;quot;), sep = &amp;quot;_&amp;quot;) %&amp;gt;%
  mutate_at(vars(Year1), ~factor(., levels = c(2013, 2009, 2005))) %&amp;gt;%
  ggplot(aes(x = Year2, y = Year1, fill = r)) +
    geom_raster() + 
  scale_fill_gradient2(low = &amp;quot;blue&amp;quot;, high = &amp;quot;red&amp;quot;, mid = &amp;quot;white&amp;quot;, 
   midpoint = 0, limit = c(-1,1), space = &amp;quot;Lab&amp;quot;, 
   name=&amp;quot;Correlations&amp;quot;) +  
  geom_text(aes(label = round(r,2))) +
    facet_grid(T1 ~ T2) +
    theme_classic()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unnamed-chunk-5&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/Workshops/2019-08-14-workshop-1_files/figure-html/unnamed-chunk-5-1.png&#34; alt=&#34;Correlations among Personality Indicators. Values on the diagonal represent Chronbach&#39;s alpha for each scale in each year. Within-trait correlations represent test-retest correlations.&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Correlations among Personality Indicators. Values on the diagonal represent Chronbach’s alpha for each scale in each year. Within-trait correlations represent test-retest correlations.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Privacy Policy</title>
      <link>/privacy/</link>
      <pubDate>Thu, 28 Jun 2018 00:00:00 +0100</pubDate>
      <guid>/privacy/</guid>
      <description>&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terms</title>
      <link>/terms/</link>
      <pubDate>Thu, 28 Jun 2018 00:00:00 +0100</pubDate>
      <guid>/terms/</guid>
      <description>&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Syllabus</title>
      <link>/syllabus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/syllabus/</guid>
      <description>


&lt;p&gt;&lt;strong&gt;Instructor&lt;/strong&gt;: Joshua Jackson&lt;br /&gt;
&lt;strong&gt;Office&lt;/strong&gt;: 315B&lt;br /&gt;
&lt;strong&gt;Office hours&lt;/strong&gt;: 1-2 Wednesday and by appointment&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI&lt;/strong&gt;: Emorie Beck
&lt;strong&gt;Office hours&lt;/strong&gt;: Wednesday 2-3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Course Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This course covers modern methods of handling longitudinal, repeated measures. The class will introduce the rationale of measuring change and stability over time to study phenomena, as well as how within-person designs can increase statistical power and precision compared to more traditional designs. Most the course will use multi-level models and latent (growth) curve models to specify patterns of change across time. Additional topics include: visualization, measurement invariance, time-to- event models and power. PREREQ: Use of R will be required, Familiarity with MLM and/or Structural Equation Models.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Class textbook&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Readings will be provided&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Structure of class&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Each class will cover a specific type of longitudinal model. During that class, I will provide an overview of the important considerations or motivation for this analysis. This will take the first half of the class or a little longer. The final hour of class will be devoted to walking through code and results. We’ll call this the workshop portion.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Grading&lt;/strong&gt;
Grading consists of 3 aspects:
1. Weekly “pop” quiz (36% of grade - 12 @ 3% each). Quizes consist of 1-3 questions based on the previous lecture and reading.&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Homework take homes (64% of grade - 8 @ 8% each). Homeworks will be presented in the workshop portion of the class and due 1 week later.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Schedule&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Week&lt;/th&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Topic&lt;/th&gt;
&lt;th&gt;Workshop&lt;/th&gt;
&lt;th&gt;Homework&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8/29&lt;/td&gt;
&lt;td&gt;Motivation, terms, concepts, and graphing&lt;/td&gt;
&lt;td&gt;Data Descriptives&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;9/5&lt;/td&gt;
&lt;td&gt;Growth curve basics; MLM in R: packages and procedures&lt;/td&gt;
&lt;td&gt;tidyr/lme4&lt;/td&gt;
&lt;td&gt;Hw#1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;9/12&lt;/td&gt;
&lt;td&gt;Conditional (Level 1 and 2 predictors) MLM models&lt;/td&gt;
&lt;td&gt;purrr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;9/19&lt;/td&gt;
&lt;td&gt;Polynomial, piecewise and spline models&lt;/td&gt;
&lt;td&gt;plotting redux&lt;/td&gt;
&lt;td&gt;Hw#2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;9/26&lt;/td&gt;
&lt;td&gt;Three level and group models&lt;/td&gt;
&lt;td&gt;brms&lt;/td&gt;
&lt;td&gt;Hw#3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;10/03&lt;/td&gt;
&lt;td&gt;Intensive data analysis/within person fluctuations p1&lt;/td&gt;
&lt;td&gt;brms&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;10/10&lt;/td&gt;
&lt;td&gt;Intensive data analysis/within person fluctuations p2&lt;/td&gt;
&lt;td&gt;tidybayes&lt;/td&gt;
&lt;td&gt;Hw#4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;10/17&lt;/td&gt;
&lt;td&gt;SEM and simple path models&lt;/td&gt;
&lt;td&gt;lavaan&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;10/24&lt;/td&gt;
&lt;td&gt;Latent Grown (curve) Models&lt;/td&gt;
&lt;td&gt;amelia&lt;/td&gt;
&lt;td&gt;Hw#5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10/31&lt;/td&gt;
&lt;td&gt;MI and Second order Model&lt;/td&gt;
&lt;td&gt;semPlot&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;11/7&lt;/td&gt;
&lt;td&gt;Multiple group models&lt;/td&gt;
&lt;td&gt;lavaan&lt;/td&gt;
&lt;td&gt;Hw#6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;11/14&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Class canceled&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;11/21&lt;/td&gt;
&lt;td&gt;Flexible SEM models (LCM, STATE-TRAIT; ALT-SR)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Hw#7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;11/28&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Tofurkey day&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;12/5&lt;/td&gt;
&lt;td&gt;Mixture Models&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Hw#8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Other topics: Longitudinal mediation (and multilevel mediation), two wave data, experimental approaches&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
